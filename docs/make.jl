using GeometryOps, GeometryOpsCore
using Documenter, DocumenterVitepress
using Literate
using Makie, CairoMakie
CairoMakie.activate!(px_per_unit = 2, type = "svg", inline = true) # TODO: make this svg

# import packages that activate extensions
import FlexiJoins, LibGEOS, Proj, TGGeometry

DocMeta.setdocmeta!(GeometryOps, :DocTestSetup, :(using GeometryOps; using GeometryBasics; using GeometryOps.GeometryOpsCore); recursive=true)

using GeoInterfaceMakie

include(joinpath(dirname(@__DIR__), "benchmarks", "benchmark_plots.jl"))

# First, remove any codecov files that may have been generated by the CI run
for (root, dirs, files) in walkdir(dirname(@__DIR__)) # walk through `GeometryOps/*`
    # Iterate through all files in the current directory
    for file in files
        # If the file is a codecov file, remove it
        if splitext(file)[2] == ".cov"
            rm(joinpath(root, file))
        end
    end
end

# Now, we convert the source code to markdown files using Literate.jl
source_path = joinpath(dirname(@__DIR__), "src")
output_path = joinpath(@__DIR__, "src", "source")
mkpath(output_path)

literate_pages = Any[]

# We don't want Literate to convert the code into Documenter blocks, so we use a custom postprocessor
# to add the `@meta` block to the markdown file, which will be used by Documenter to add an edit link.
function _add_meta_edit_link_generator(path)
    return function (input)
        return """
        ```@meta
        EditURL = "$(path).jl"
        ```

        """ * input # we add `.jl` because `relpath` eats the file extension, apparently :shrug:
    end
end

function _add_meta_current_module(current_module::String)
    return function (input)
        return """
        ```@meta
        CurrentModule = $(current_module)
        ```
        """ * input
    end
end

# First letter of `str` is made uppercase and returned
ucfirst(str::String) = string(uppercase(str[1]), str[2:end])

function current_module_from_paths(source_path, relative_path)
    if contains(source_path, "GeometryOpsCore")
        return "GeometryOpsCore"
    elseif endswith(source_path, "src")
        return "GeometryOps"
    elseif endswith(source_path, "ext")
        return "Base.get_extension(GeometryOps, :$(splitpath(relative_path)[1]))"
    elseif contains(relative_path, "SpatialTreeInterface")
        return "GeometryOps.SpatialTreeInterface"
    elseif contains(relative_path, "LoopStateMachine")
        return "GeometryOps.LoopStateMachine"
    elseif contains(relative_path, "NaturalIndexing")
        return "GeometryOps.NaturalIndexing"
    else
        return "GeometryOps" # default to GO as a last resort
    end
end

function process_literate_recursive!(pages::Vector{Any}, path::String)
    global source_path
    global output_path
    if isdir(path)
        contents = []
        process_literate_recursive!.((contents,), normpath.(readdir(path; join = true)))
        push!(pages, ucfirst(splitdir(path)[2]) => contents)
    elseif isfile(path)
        if endswith(path, ".jl")
            relative_path = relpath(path, source_path)
            output_dir = joinpath(output_path, splitdir(relative_path)[1])
            
            Literate.markdown(
                path, output_dir; 
                flavor = Literate.CommonMarkFlavor(), 
                postprocess = _add_meta_edit_link_generator(joinpath(relpath(source_path, output_dir), relative_path)) âˆ˜ _add_meta_current_module(current_module_from_paths(source_path, relative_path))
            )
            push!(pages, joinpath("source", splitext(relative_path)[1] * ".md"))
        end
    end
end

withenv("JULIA_DEBUG" => "Literate") do # allow Literate debug output to escape to the terminal!
    global literate_pages
    empty!(literate_pages)
    vec = []
    process_literate_recursive!(vec, source_path)
    literate_pages = vec[1][2] # this is a hack to get the pages in the correct order, without an initial "src" folder.  

    global source_path
    source_path = joinpath(dirname(@__DIR__), "GeometryOpsCore")
    core_stuff = []
    process_literate_recursive!(core_stuff, source_path)
    push!(literate_pages, "GeometryOpsCore" => core_stuff[1][2])

    global source_path
    source_path = joinpath(dirname(@__DIR__), "ext")
    ext_stuff = []
    process_literate_recursive!(ext_stuff, source_path)
    push!(literate_pages, "Extensions" => ext_stuff[1][2])
    # TODO: We should probably fix the above in `process_literate_recursive!`.
end

# Now that the Literate stuff is done, we also download the call notes from HackMD:
# download("https://hackmd.io/kpIqAR8YRJOZQDJjUKVAUQ/download", joinpath(@__DIR__, "src", "call_notes.md"))
# This is a bit unreliable especially at high volumes of traffic, so we don't call this for now.

# Finally, make the docs!
makedocs(;
    modules=[GeometryOps, GeometryOpsCore],
    authors="Anshul Singhvi <anshulsinghvi@gmail.com> and contributors",
    repo="https://github.com/JuliaGeo/GeometryOps.jl/blob/{commit}{path}#{line}",
    sitename="GeometryOps.jl",
    format = DocumenterVitepress.MarkdownVitepress(
        repo = "github.com/JuliaGeo/GeometryOps.jl",
    ),
    pages=[
        "Introduction" => "introduction.md",
        "API Reference" => "api.md",
        "Tutorials" => [
            "Creating Geometry" => "tutorials/creating_geometry.md",
            "Rotating Geometry" => "tutorials/rotating_geometry.md",
            "Spatial Joins" => "tutorials/spatial_joins.md",
        ],
        "Explanations" => [
            "Paradigms" => "explanations/paradigms.md",
            "Manifolds" => "explanations/manifolds.md",
            "Performance" => "explanations/performance.md",
            "Peculiarities" => "explanations/peculiarities.md",
            "GIS terminology" => [
                "CRS" => "explanations/crs.md",
                "Winding order" => "explanations/winding_order.md",
                # "Geometry types and lack of support" => "explanations/well_known_geometry.md", # TODO write this
                # "When you should use LibGEOS or ArchGDAL" => "explanations/notgeometryops.md", # TODO write this
            ],
            "Developer docs" => "explanations/devdocs.md",
        ],
        "Source code" => literate_pages,
    ],
    warnonly = true,
)

DocumenterVitepress.deploydocs(;
    repo="github.com/JuliaGeo/GeometryOps.jl",
    devbranch="main",
    push_preview = true,
)
