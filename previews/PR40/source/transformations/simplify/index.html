<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Geometry simplification · GeometryOps.jl</title><script data-outdated-warner src="../../../assets/warner.js"></script><link rel="canonical" href="https://asinghvi17.github.io/GeometryOps.jl/source/transformations/simplify/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../"><img src="../../../assets/logo.png" alt="GeometryOps.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">GeometryOps.jl</a></span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Source code</span><ul><li><a class="tocitem" href="../../GeometryOps/">GeometryOps.jl</a></li><li><a class="tocitem" href="../../primitives/">Primitive functions</a></li><li><a class="tocitem" href="../../utils/">Utility functions</a></li><li><a class="tocitem" href="../../methods/area/">Area and signed area</a></li><li><a class="tocitem" href="../../methods/barycentric/">Barycentric coordinates</a></li><li><a class="tocitem" href="../../methods/bools/">Boolean conditions</a></li><li><a class="tocitem" href="../../methods/centroid/">Centroid</a></li><li><a class="tocitem" href="../../methods/distance/">Distance and signed distance</a></li><li><a class="tocitem" href="../../methods/equals/">Equals</a></li><li><a class="tocitem" href="../../methods/polygonize/">Polygonizing raster data</a></li><li><a class="tocitem" href="../../methods/geom_relations/contains/">Contains</a></li><li><a class="tocitem" href="../../methods/geom_relations/coveredby/">CoveredBy</a></li><li><a class="tocitem" href="../../methods/geom_relations/covers/">Covers</a></li><li><a class="tocitem" href="../../methods/geom_relations/crosses/">Crossing checks</a></li><li><a class="tocitem" href="../../methods/geom_relations/disjoint/">Disjoint</a></li><li><a class="tocitem" href="../../methods/geom_relations/geom_geom_processors/">-</a></li><li><a class="tocitem" href="../../methods/geom_relations/intersects/">Intersection checks</a></li><li><a class="tocitem" href="../../methods/geom_relations/overlaps/">Overlaps</a></li><li><a class="tocitem" href="../../methods/geom_relations/touches/">Touches</a></li><li><a class="tocitem" href="../../methods/geom_relations/within/">Within</a></li><li><a class="tocitem" href="../extent/">-</a></li><li><a class="tocitem" href="../flip/">Coordinate flipping</a></li><li><a class="tocitem" href="../reproject/">Geometry reprojection</a></li><li class="is-active"><a class="tocitem" href>Geometry simplification</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Simplify-with-RadialDistance-Algorithm"><span>Simplify with RadialDistance Algorithm</span></a></li><li class="toplevel"><a class="tocitem" href="#Simplify-with-DouglasPeucker-Algorithm"><span>Simplify with DouglasPeucker Algorithm</span></a></li><li class="toplevel"><a class="tocitem" href="#Simplify-with-VisvalingamWhyatt-Algorithm"><span>Simplify with VisvalingamWhyatt Algorithm</span></a></li><li class="toplevel"><a class="tocitem" href="#Shared-utils"><span>Shared utils</span></a></li></ul></li><li><a class="tocitem" href="../transform/">-</a></li><li><a class="tocitem" href="../tuples/">Tuple conversion</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Source code</a></li><li class="is-active"><a href>Geometry simplification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Geometry simplification</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/asinghvi17/GeometryOps.jl/blob/main/docs/src/source/transformations/simplify.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Geometry-simplification"><a class="docs-heading-anchor" href="#Geometry-simplification">Geometry simplification</a><a id="Geometry-simplification-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-simplification" title="Permalink"></a></h1><p>This file holds implementations for the RadialDistance, Douglas-Peucker, and Visvalingam-Whyatt algorithms for simplifying geometries (specifically for polygons and lines).</p><pre><code class="language-julia hljs">export simplify, VisvalingamWhyatt, DouglasPeucker, RadialDistance

const MIN_POINTS = 3
const SIMPLIFY_ALG_KEYWORDS = &quot;&quot;&quot;
# Keywords

- `ratio`: the fraction of points that should remain after `simplify`.
    Useful as it will generalise for large collections of objects.
- `number`: the number of points that should remain after `simplify`.
    Less useful for large collections of mixed size objects.
&quot;&quot;&quot;
const DOUGLAS_PEUCKER_KEYWORDS = &quot;&quot;&quot;
$SIMPLIFY_ALG_KEYWORDS
- `tol`: the minimum distance a point will be from the line
    joining its neighboring points.
&quot;&quot;&quot;

&quot;&quot;&quot;
    abstract type SimplifyAlg

Abstract type for simplification algorithms.

# API

For now, the algorithm must hold the `number`, `ratio` and `tol` properties.

Simplification algorithm types can hook into the interface by implementing
the `_simplify(trait, alg, geom)` methods for whichever traits are necessary.
&quot;&quot;&quot;
abstract type SimplifyAlg end

&quot;&quot;&quot;
    simplify(obj; kw...)
    simplify(::SimplifyAlg, obj; kw...)

Simplify a geometry, feature, feature collection,
or nested vectors or a table of these.

`RadialDistance`, `DouglasPeucker`, or
`VisvalingamWhyatt` algorithms are available,
listed in order of increasing quality but decreaseing performance.

`PoinTrait` and `MultiPointTrait` are returned unchanged.

The default behaviour is `simplify(DouglasPeucker(; kw...), obj)`.
Pass in other `SimplifyAlg` to use other algorithms.</code></pre><p>Keywords</p><pre><code class="language-julia hljs">- `prefilter_alg`: `SimplifyAlg` algorithm used to pre-filter object before
    using primary filtering algorithm.
$APPLY_KEYWORDS


Keywords for DouglasPeucker are allowed when no algorithm is specified:

$DOUGLAS_PEUCKER_KEYWORDS</code></pre><p>Example</p><pre><code class="language-julia hljs">Simplify a polygon to have six points:

```jldoctest
import GeoInterface as GI
import GeometryOps as GO

poly = GI.Polygon([[
    [-70.603637, -33.399918],
    [-70.614624, -33.395332],
    [-70.639343, -33.392466],
    [-70.659942, -33.394759],
    [-70.683975, -33.404504],
    [-70.697021, -33.419406],
    [-70.701141, -33.434306],
    [-70.700454, -33.446339],
    [-70.694274, -33.458369],
    [-70.682601, -33.465816],
    [-70.668869, -33.472117],
    [-70.646209, -33.473835],
    [-70.624923, -33.472117],
    [-70.609817, -33.468107],
    [-70.595397, -33.458369],
    [-70.587158, -33.442901],
    [-70.587158, -33.426283],
    [-70.590591, -33.414248],
    [-70.594711, -33.406224],
    [-70.603637, -33.399918]]])

simple = GO.simplify(poly; number=6)
GI.npoint(simple)</code></pre><p>output</p><pre><code class="language-julia hljs">6
```
&quot;&quot;&quot;
simplify(alg::SimplifyAlg, data; kw...) = _simplify(alg, data; kw...)</code></pre><p>Default algorithm is DouglasPeucker</p><pre><code class="language-julia hljs">simplify(
    data; prefilter_alg = nothing,
    calc_extent=false, threaded=false, crs=nothing, kw...,
 ) = _simplify(DouglasPeucker(; kw...), data; prefilter_alg, calc_extent, threaded, crs)

#= For each algorithm, apply simplication to all curves, multipoints, and
points, reconstructing everything else around them. =#
function _simplify(alg::SimplifyAlg, data; prefilter_alg = nothing, kw...)
    simplifier(geom) = _simplify(GI.trait(geom), alg, geom; prefilter_alg = prefilter_alg)
    return apply(
        simplifier,
        Union{GI.PolygonTrait, GI.AbstractCurveTrait, GI.MultiPointTrait, GI.PointTrait},
        data;
        kw...,
    )
end


# For Point and MultiPoint traits we do nothing
_simplify(::GI.PointTrait, alg, geom; kw...) = geom
_simplify(::GI.MultiPointTrait, alg, geom; kw...) = geom

# For curves, rings, and polygon we simplify
function _simplify(
    ::GI.AbstractCurveTrait, alg, geom;
    prefilter_alg, preserve_endpoint = true,
)
    points = if isnothing(prefilter_alg)
        tuple_points(geom)
    else
        _simplify(prefilter_alg, tuple_points(geom), preserve_endpoint)
    end
    return rebuild(geom, _simplify(alg, points, preserve_endpoint))
end

function _simplify(::GI.PolygonTrait, alg, geom;  kw...)
    # Force treating children as LinearRing
    simplifier(g) = _simplify(
        GI.LinearRingTrait(), alg, g;
        kw..., preserve_endpoint = false,
    )
    rebuilder(g) = rebuild(g, simplifier(g))
    lrs = map(rebuilder, GI.getgeom(geom))
    return rebuild(geom, lrs)
end</code></pre><h1 id="Simplify-with-RadialDistance-Algorithm"><a class="docs-heading-anchor" href="#Simplify-with-RadialDistance-Algorithm">Simplify with RadialDistance Algorithm</a><a id="Simplify-with-RadialDistance-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Simplify-with-RadialDistance-Algorithm" title="Permalink"></a></h1><pre><code class="language-julia hljs">&quot;&quot;&quot;
    RadialDistance &lt;: SimplifyAlg

Simplifies geometries by removing points less than
`tol` distance from the line between its neighboring points.

$SIMPLIFY_ALG_KEYWORDS
- `tol`: the minimum distance between points.

Note: user input `tol` is squared to avoid uneccesary computation in algorithm.
&quot;&quot;&quot;
@kwdef struct RadialDistance &lt;: SimplifyAlg
    number::Union{Int64,Nothing} = nothing
    ratio::Union{Float64,Nothing} = nothing
    tol::Union{Float64,Nothing} = nothing

    function RadialDistance(number, ratio, tol)
        _checkargs(number, ratio, tol)</code></pre><p>square tolerance for reduced computation</p><pre><code class="language-julia hljs">        tol = isnothing(tol) ? tol : tol^2
        new(number, ratio, tol)
    end
end

function _simplify(alg::RadialDistance, points::Vector, _)
    previous = first(points)
    distances = Array{Float64}(undef, length(points))
    for i in eachindex(points)
        point = points[i]
        distances[i] = _squared_euclid_distance(Float64, point, previous)
        previous = point
    end
    # Never remove the end points
    distances[begin] = distances[end] = Inf
    return _get_points(alg, points, distances)
end</code></pre><h1 id="Simplify-with-DouglasPeucker-Algorithm"><a class="docs-heading-anchor" href="#Simplify-with-DouglasPeucker-Algorithm">Simplify with DouglasPeucker Algorithm</a><a id="Simplify-with-DouglasPeucker-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Simplify-with-DouglasPeucker-Algorithm" title="Permalink"></a></h1><pre><code class="language-julia hljs">&quot;&quot;&quot;
    DouglasPeucker &lt;: SimplifyAlg

    DouglasPeucker(; number, ratio, tol)

Simplifies geometries by removing points below `tol`
distance from the line between its neighboring points.

$DOUGLAS_PEUCKER_KEYWORDS
Note: user input `tol` is squared to avoid uneccesary computation in algorithm.
&quot;&quot;&quot;
@kwdef struct DouglasPeucker &lt;: SimplifyAlg
    number::Union{Int64,Nothing} = nothing
    ratio::Union{Float64,Nothing} = nothing
    tol::Union{Float64,Nothing} = nothing

    function DouglasPeucker(number, ratio, tol)
        _checkargs(number, ratio, tol)</code></pre><p>square tolerance for reduced computation</p><pre><code class="language-julia hljs">        tol = isnothing(tol) ? tol : tol^2
        return new(number, ratio, tol)
    end
end

#= Simplify using the DouglasPeucker algorithm - nice gif of process on wikipedia:
(https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm). =#
function _simplify(alg::DouglasPeucker, points::Vector, preserve_endpoint)
    npoints = length(points)
    npoints &lt;= MIN_POINTS &amp;&amp; return points</code></pre><p>Determine stopping critetia</p><pre><code class="language-julia hljs">    max_points = if !isnothing(alg.tol)
        npoints
    else
        npts = !isnothing(alg.number) ? alg.number : max(3, round(Int, alg.ratio * npoints))
        npts ≥ npoints &amp;&amp; return points
        npts
    end
    max_tol = !isnothing(alg.tol) ? alg.tol : zero(Float64)</code></pre><p>Set up queue</p><pre><code class="language-julia hljs">    queue = Vector{Tuple{Int, Int, Int, Float64}}()
    queue_idx, queue_dist = 0, zero(Float64)
    len_queue = 0</code></pre><p>Set up results vector</p><pre><code class="language-julia hljs">    results = Vector{Int}(undef, max_points + (preserve_endpoint ? 0 : 1))
    results[1], results[2] = 1, npoints</code></pre><p>Loop through points until stopping criteria are fulfilled</p><pre><code class="language-julia hljs">    i = 2  # already have first and last point added
    start_idx, end_idx = 1, npoints
    max_idx, max_dist = _find_max_squared_dist(points, start_idx, end_idx)
    while i &lt; max_points &amp;&amp; max_dist &gt; max_tol</code></pre><p>Add next point to results</p><pre><code class="language-julia hljs">        i += 1
        results[i] = max_idx</code></pre><p>Determine which point to add next by checking left and right of point</p><pre><code class="language-julia hljs">        left_idx, left_dist = _find_max_squared_dist(points, start_idx, max_idx)
        right_idx, right_dist = _find_max_squared_dist(points, max_idx, end_idx)
        left_vals = (start_idx, left_idx, max_idx, left_dist)
        right_vals = (max_idx, right_idx, end_idx, right_dist)</code></pre><p>Add and remove values from queue</p><pre><code class="language-julia hljs">        if queue_dist &gt; left_dist &amp;&amp; queue_dist &gt; right_dist</code></pre><p>Value in queue is next value to add to results</p><pre><code class="language-julia hljs">            start_idx, max_idx, end_idx, max_dist = queue[queue_idx]</code></pre><p>Add left and/or right values to queue or delete used queue value</p><pre><code class="language-julia hljs">            if left_dist &gt; 0
                queue[queue_idx] = left_vals
                if right_dist &gt; 0
                    push!(queue, right_vals)
                    len_queue += 1
                end
            elseif right_dist &gt; 0
                queue[queue_idx] = right_vals
            else
                deleteat!(queue, queue_idx)
                len_queue =- 1
            end</code></pre><p>Determine new maximum queue value</p><pre><code class="language-julia hljs">            queue_dist, queue_idx = !isempty(queue) ?
                findmax(x -&gt; x[4], queue) : (zero(Float64), 0)
        elseif left_dist &gt; right_dist  # use left value as next value to add to results
            push!(queue, right_vals)  # add right value to queue
            len_queue += 1
            if right_dist &gt; queue_dist
                queue_dist = right_dist
                queue_idx = len_queue
            end
            start_idx, max_idx, end_idx, max_dist = left_vals
        else  # use right value as next value to add to results
            push!(queue, left_vals)  # add left value to queue
            len_queue += 1
            if left_dist &gt; queue_dist
                queue_dist = left_dist
                queue_idx = len_queue
            end
            start_idx, max_idx, end_idx, max_dist = right_vals
        end
    end
    sorted_results = sort!(@view results[1:i])
    if !preserve_endpoint &amp;&amp; i &gt; 3
        endpt_dist = _squared_distance_line(Float64, points[1], points[end - 1], points[2])
        if !isnothing(alg.tol)
            if endpt_dist &lt; max_tol
                results[i] = results[2]
                sorted_results = @view results[2:i]
            end
        else
            if endpt_dist &lt; max_dist
                insert!(results, searchsortedfirst(sorted_results, max_idx), max_idx)
                results[i+1] = results[2]
                sorted_results = @view results[2:i+1]
            end
        end
    end
    return points[sorted_results]
end

#= find maximum distance of any point between the start_idx and end_idx to the line formed
by conencting the points at start_idx and end_idx. Note that the first index of maximum
value will be used, which might cause differences in results from other algorithms.=#
function _find_max_squared_dist(points, start_idx, end_idx)
    max_idx = 0
    max_dist = zero(Float64)
    for i in (start_idx + 1):(end_idx - 1)
        d = _squared_distance_line(Float64, points[i], points[start_idx], points[end_idx])
        if d &gt; max_dist
            max_dist = d
            max_idx = i
        end
    end
    return max_idx, max_dist
end</code></pre><h1 id="Simplify-with-VisvalingamWhyatt-Algorithm"><a class="docs-heading-anchor" href="#Simplify-with-VisvalingamWhyatt-Algorithm">Simplify with VisvalingamWhyatt Algorithm</a><a id="Simplify-with-VisvalingamWhyatt-Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Simplify-with-VisvalingamWhyatt-Algorithm" title="Permalink"></a></h1><pre><code class="language-julia hljs">&quot;&quot;&quot;
    VisvalingamWhyatt &lt;: SimplifyAlg

    VisvalingamWhyatt(; kw...)

Simplifies geometries by removing points below `tol`
distance from the line between its neighboring points.

$SIMPLIFY_ALG_KEYWORDS
- `tol`: the minimum area of a triangle made with a point and
    its neighboring points.
Note: user input `tol` is doubled to avoid uneccesary computation in algorithm.
&quot;&quot;&quot;
@kwdef struct VisvalingamWhyatt &lt;: SimplifyAlg
    number::Union{Int,Nothing} = nothing
    ratio::Union{Float64,Nothing} = nothing
    tol::Union{Float64,Nothing} = nothing

    function VisvalingamWhyatt(number, ratio, tol)
        _checkargs(number, ratio, tol)</code></pre><p>double tolerance for reduced computation</p><pre><code class="language-julia hljs">        tol = isnothing(tol) ? tol : tol*2
        return new(number, ratio, tol)
    end
end

function _simplify(alg::VisvalingamWhyatt, points::Vector, _)
    length(points) &lt;= MIN_POINTS &amp;&amp; return points
    areas = _build_tolerances(_triangle_double_area, points)
    return _get_points(alg, points, areas)
end</code></pre><p>Calculates double the area of a triangle given its vertices</p><pre><code class="language-julia hljs">_triangle_double_area(p1, p2, p3) =
    abs(p1[1] * (p2[2] - p3[2]) + p2[1] * (p3[2] - p1[2]) + p3[1] * (p1[2] - p2[2]))</code></pre><h1 id="Shared-utils"><a class="docs-heading-anchor" href="#Shared-utils">Shared utils</a><a id="Shared-utils-1"></a><a class="docs-heading-anchor-permalink" href="#Shared-utils" title="Permalink"></a></h1><pre><code class="language-julia hljs">function _build_tolerances(f, points)
    nmax = length(points)
    real_tolerances = _flat_tolerances(f, points)

    tolerances = copy(real_tolerances)
    i = collect(1:nmax)

    min_vert = argmin(tolerances)
    this_tolerance = tolerances[min_vert]
    _remove!(tolerances, min_vert)
    deleteat!(i, min_vert)

    while this_tolerance &lt; Inf
        skip = false

        if min_vert &lt; length(i)
            right_tolerance = f(
                points[i[min_vert - 1]],
                points[i[min_vert]],
                points[i[min_vert + 1]],
            )
            if right_tolerance &lt;= this_tolerance
                right_tolerance = this_tolerance
                skip = min_vert == 1
            end

            real_tolerances[i[min_vert]] = right_tolerance
            tolerances[min_vert] = right_tolerance
        end

        if min_vert &gt; 2
            left_tolerance = f(
                points[i[min_vert - 2]],
                points[i[min_vert - 1]],
                points[i[min_vert]],
            )
            if left_tolerance &lt;= this_tolerance
                left_tolerance = this_tolerance
                skip = min_vert == 2
            end
            real_tolerances[i[min_vert - 1]] = left_tolerance
            tolerances[min_vert - 1] = left_tolerance
        end

        if !skip
            min_vert = argmin(tolerances)
        end
        deleteat!(i, min_vert)
        this_tolerance = tolerances[min_vert]
        _remove!(tolerances, min_vert)
    end

    return real_tolerances
end

function tuple_points(geom)
    points = Array{Tuple{Float64,Float64}}(undef, GI.npoint(geom))
    for (i, p) in enumerate(GI.getpoint(geom))
        points[i] = (GI.x(p), GI.y(p))
    end
    return points
end

function _get_points(alg, points, tolerances)
    # This assumes that `alg` has the properties
    # `tol`, `number`, and `ratio` available...
    tol = alg.tol
    number = alg.number
    ratio = alg.ratio
    bit_indices = if !isnothing(tol)
        _tol_indices(alg.tol::Float64, points, tolerances)
    elseif !isnothing(number)
        _number_indices(alg.number::Int64, points, tolerances)
    else
        _ratio_indices(alg.ratio::Float64, points, tolerances)
    end
    return points[bit_indices]
end

function _tol_indices(tol, points, tolerances)
    tolerances .&gt;= tol
end

function _number_indices(n, points, tolerances)
    tol = partialsort(tolerances, length(points) - n + 1)
    bit_indices = _tol_indices(tol, points, tolerances)
    nselected = sum(bit_indices)
    # If there are multiple values exactly at `tol` we will get
    # the wrong output length. So we need to remove some.
    while nselected &gt; n
        min_tol = Inf
        min_i = 0
        for i in eachindex(bit_indices)
            bit_indices[i] || continue
            if tolerances[i] &lt; min_tol
                min_tol = tolerances[i]
                min_i = i
            end
        end
        nselected -= 1
        bit_indices[min_i] = false
    end
    return bit_indices
end

function _ratio_indices(r, points, tolerances)
    n = max(3, round(Int, r * length(points)))
    return _number_indices(n, points, tolerances)
end

function _flat_tolerances(f, points)
    result = Array{Float64}(undef, length(points))
    result[1] = result[end] = Inf

    for i in 2:length(result) - 1
        result[i] = f(points[i-1], points[i], points[i+1])
    end
    return result
end

_remove!(s, i) = s[i:end-1] .= s[i+1:end]</code></pre><p>Check SimplifyAlgs inputs to make sure they are valid for below algorithms</p><pre><code class="language-julia hljs">function _checkargs(number, ratio, tol)
    count(isnothing, (number, ratio, tol)) == 2 ||
        error(&quot;Must provide one of `number`, `ratio` or `tol` keywords&quot;)
    if !isnothing(number)
        if number &lt; MIN_POINTS
            error(&quot;`number` must be $MIN_POINTS or larger. Got $number&quot;)
        end
    elseif !isnothing(ratio)
        if ratio &lt;= 0 || ratio &gt; 1
            error(&quot;`ratio` must be 0 &lt; ratio &lt;= 1. Got $ratio&quot;)
        end
    else  # !isnothing(tol)
        if tol ≤ 0
            error(&quot;`tol` must be a positive number. Got $tol&quot;)
        end
    end
    return nothing
end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../reproject/">« Geometry reprojection</a><a class="docs-footer-nextpage" href="../transform/">- »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 12 January 2024 21:29">Friday 12 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
