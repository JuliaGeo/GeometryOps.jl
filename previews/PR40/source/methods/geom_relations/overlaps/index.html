<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overlaps · GeometryOps.jl</title><script data-outdated-warner src="../../../../assets/warner.js"></script><link rel="canonical" href="https://asinghvi17.github.io/GeometryOps.jl/source/methods/geom_relations/overlaps/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../../assets/documenter.js"></script><script src="../../../../siteinfo.js"></script><script src="../../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../../../"><img src="../../../../assets/logo.png" alt="GeometryOps.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../../../">GeometryOps.jl</a></span></div><form class="docs-search" action="../../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../../">Home</a></li><li><span class="tocitem">Source code</span><ul><li><a class="tocitem" href="../../../GeometryOps/">GeometryOps.jl</a></li><li><a class="tocitem" href="../../../primitives/">Primitive functions</a></li><li><a class="tocitem" href="../../../utils/">Utility functions</a></li><li><a class="tocitem" href="../../area/">Area and signed area</a></li><li><a class="tocitem" href="../../barycentric/">Barycentric coordinates</a></li><li><a class="tocitem" href="../../bools/">Boolean conditions</a></li><li><a class="tocitem" href="../../centroid/">Centroid</a></li><li><a class="tocitem" href="../../distance/">Distance and signed distance</a></li><li><a class="tocitem" href="../../equals/">Equals</a></li><li><a class="tocitem" href="../../polygonize/">Polygonizing raster data</a></li><li><a class="tocitem" href="../contains/">Contains</a></li><li><a class="tocitem" href="../coveredby/">CoveredBy</a></li><li><a class="tocitem" href="../covers/">Covers</a></li><li><a class="tocitem" href="../crosses/">Crossing checks</a></li><li><a class="tocitem" href="../disjoint/">Disjoint</a></li><li><a class="tocitem" href="../geom_geom_processors/">-</a></li><li><a class="tocitem" href="../intersects/">Intersection checks</a></li><li class="is-active"><a class="tocitem" href>Overlaps</a><ul class="internal"><li><a class="tocitem" href="#What-is-overlaps?"><span>What is overlaps?</span></a></li><li><a class="tocitem" href="#Implementation"><span>Implementation</span></a></li></ul></li><li><a class="tocitem" href="../touches/">Touches</a></li><li><a class="tocitem" href="../within/">Within</a></li><li><a class="tocitem" href="../../../transformations/extent/">-</a></li><li><a class="tocitem" href="../../../transformations/flip/">Coordinate flipping</a></li><li><a class="tocitem" href="../../../transformations/reproject/">Geometry reprojection</a></li><li><a class="tocitem" href="../../../transformations/simplify/">Geometry simplification</a></li><li><a class="tocitem" href="../../../transformations/transform/">-</a></li><li><a class="tocitem" href="../../../transformations/tuples/">Tuple conversion</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Source code</a></li><li class="is-active"><a href>Overlaps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overlaps</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/asinghvi17/GeometryOps.jl/blob/main/docs/src/source/methods/geom_relations/overlaps.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Overlaps"><a class="docs-heading-anchor" href="#Overlaps">Overlaps</a><a id="Overlaps-1"></a><a class="docs-heading-anchor-permalink" href="#Overlaps" title="Permalink"></a></h1><pre><code class="language-julia hljs">export overlaps</code></pre><h2 id="What-is-overlaps?"><a class="docs-heading-anchor" href="#What-is-overlaps?">What is overlaps?</a><a id="What-is-overlaps?-1"></a><a class="docs-heading-anchor-permalink" href="#What-is-overlaps?" title="Permalink"></a></h2><p>The overlaps function checks if two geometries overlap. Two geometries can only overlap if they have the same dimension, and if they overlap, but one is not contained, within, or equal to the other.</p><p>Note that this means it is impossible for a single point to overlap with a single point and a line only overlaps with another line if only a section of each line is colinear.</p><p>To provide an example, consider these two lines:</p><pre><code class="language- hljs">using GeometryOps
using GeometryOps.GeometryBasics
using Makie
using CairoMakie

l1 = GI.LineString([(0.0, 0.0), (0.0, 10.0)])
l2 = GI.LineString([(0.0, -10.0), (0.0, 3.0)])
f, a, p = lines(GI.getpoint(l1), color = :blue)
scatter!(GI.getpoint(l1), color = :blue)
lines!(GI.getpoint(l2), color = :orange)
scatter!(GI.getpoint(l2), color = :orange)</code></pre><p>We can see that the two lines overlap in the plot:</p><pre><code class="language- hljs">overlap(l1, l2)</code></pre><h2 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h2><p>This is the GeoInterface-compatible implementation.</p><p>First, we implement a wrapper method that dispatches to the correct implementation based on the geometry trait. This is also used in the implementation, since it&#39;s a lot less work!</p><p>Note that that since only elements of the same dimension can overlap, any two geometries with traits that are of different dimensions autmoatically can return false.</p><p>For geometries with the same trait dimension, we must make sure that they share a point, an edge, or area for points, lines, and polygons/multipolygons respectivly, without being contained.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    overlaps(geom1, geom2)::Bool

Compare two Geometries of the same dimension and return true if their
intersection set results in a geometry different from both but of the same
dimension. This means one geometry cannot be within or contain the other and
they cannot be equal

# Examples
```jldoctest
import GeometryOps as GO, GeoInterface as GI
poly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])
poly2 = GI.Polygon([[(1,1), (1,6), (6,6), (6,1), (1,1)]])

GO.overlaps(poly1, poly2)</code></pre><p>output</p><pre><code class="language-julia hljs">true
```
&quot;&quot;&quot;
overlaps(geom1, geom2)::Bool = overlaps(
    GI.trait(geom1),
    geom1,
    GI.trait(geom2),
    geom2,
)

&quot;&quot;&quot;
    overlaps(::GI.AbstractTrait, geom1, ::GI.AbstractTrait, geom2)::Bool

For any non-specified pair, all have non-matching dimensions, return false.
&quot;&quot;&quot;
overlaps(::GI.AbstractTrait, geom1, ::GI.AbstractTrait, geom2) = false

&quot;&quot;&quot;
    overlaps(
        ::GI.MultiPointTrait, points1,
        ::GI.MultiPointTrait, points2,
    )::Bool

If the multipoints overlap, meaning some, but not all, of the points within the
multipoints are shared, return true.
&quot;&quot;&quot;
function overlaps(
    ::GI.MultiPointTrait, points1,
    ::GI.MultiPointTrait, points2,
)
    one_diff = false  # assume that all the points are the same
    one_same = false  # assume that all points are different
    for p1 in GI.getpoint(points1)
        match_point = false
        for p2 in GI.getpoint(points2)
            if equals(p1, p2)  # Point is shared
                one_same = true
                match_point = true
                break
            end
        end
        one_diff |= !match_point  # Point isn&#39;t shared
        one_same &amp;&amp; one_diff &amp;&amp; return true
    end
    return false
end

&quot;&quot;&quot;
    overlaps(::GI.LineTrait, line1, ::GI.LineTrait, line)::Bool

If the lines overlap, meaning that they are colinear but each have one endpoint
outside of the other line, return true. Else false.
&quot;&quot;&quot;
overlaps(::GI.LineTrait, line1, ::GI.LineTrait, line) =
    _overlaps((a1, a2), (b1, b2))

&quot;&quot;&quot;
    overlaps(
        ::Union{GI.LineStringTrait, GI.LinearRing}, line1,
        ::Union{GI.LineStringTrait, GI.LinearRing}, line2,
    )::Bool

If the curves overlap, meaning that at least one edge of each curve overlaps,
return true. Else false.
&quot;&quot;&quot;
function overlaps(
    ::Union{GI.LineStringTrait, GI.LinearRing}, line1,
    ::Union{GI.LineStringTrait, GI.LinearRing}, line2,
)
    edges_a, edges_b = map(sort! ∘ to_edges, (line1, line2))
    for edge_a in edges_a
        for edge_b in edges_b
            _overlaps(edge_a, edge_b) &amp;&amp; return true
        end
    end
    return false
end

&quot;&quot;&quot;
    overlaps(
        trait_a::GI.PolygonTrait, poly_a,
        trait_b::GI.PolygonTrait, poly_b,
    )::Bool

If the two polygons intersect with one another, but are not equal, return true.
Else false.
&quot;&quot;&quot;
function overlaps(
    trait_a::GI.PolygonTrait, poly_a,
    trait_b::GI.PolygonTrait, poly_b,
)
    edges_a, edges_b = map(sort! ∘ to_edges, (poly_a, poly_b))
    return _edge_intersects(edges_a, edges_b) &amp;&amp;
        !equals(trait_a, poly_a, trait_b, poly_b)
end

&quot;&quot;&quot;
    overlaps(
        ::GI.PolygonTrait, poly1,
        ::GI.MultiPolygonTrait, polys2,
    )::Bool

Return true if polygon overlaps with at least one of the polygons within the
multipolygon. Else false.
&quot;&quot;&quot;
function overlaps(
    ::GI.PolygonTrait, poly1,
    ::GI.MultiPolygonTrait, polys2,
)
    for poly2 in GI.getgeom(polys2)
        overlaps(poly1, poly2) &amp;&amp; return true
    end
    return false
end

&quot;&quot;&quot;
    overlaps(
        ::GI.MultiPolygonTrait, polys1,
        ::GI.PolygonTrait, poly2,
    )::Bool

Return true if polygon overlaps with at least one of the polygons within the
multipolygon. Else false.
&quot;&quot;&quot;
overlaps(trait1::GI.MultiPolygonTrait, polys1, trait2::GI.PolygonTrait, poly2) =
    overlaps(trait2, poly2, trait1, polys1)

&quot;&quot;&quot;
    overlaps(
        ::GI.MultiPolygonTrait, polys1,
        ::GI.MultiPolygonTrait, polys2,
    )::Bool

Return true if at least one pair of polygons from multipolygons overlap. Else
false.
&quot;&quot;&quot;
function overlaps(
    ::GI.MultiPolygonTrait, polys1,
    ::GI.MultiPolygonTrait, polys2,
)
    for poly1 in GI.getgeom(polys1)
        overlaps(poly1, polys2) &amp;&amp; return true
    end
    return false
end

#= If the edges overlap, meaning that they are colinear but each have one endpoint
outside of the other edge, return true. Else false. =#
function _overlaps(
    (a1, a2)::Edge,
    (b1, b2)::Edge
)</code></pre><p>meets in more than one point</p><pre><code class="language-julia hljs">    on_top = ExactPredicates.meet(a1, a2, b1, b2) == 0</code></pre><p>one end point is outside of other segment</p><pre><code class="language-julia hljs">    a_fully_within = _point_on_seg(a1, b1, b2) &amp;&amp; _point_on_seg(a2, b1, b2)
    b_fully_within = _point_on_seg(b1, a1, a2) &amp;&amp; _point_on_seg(b2, a1, a2)
    return on_top &amp;&amp; (!a_fully_within &amp;&amp; !b_fully_within)
end

#= TODO: Once overlaps is swapped over to use the geom relations workflow, can
delete these helpers. =#</code></pre><p>Checks it vectors of edges intersect</p><pre><code class="language-julia hljs">function _edge_intersects(
    edges_a::Vector{Edge},
    edges_b::Vector{Edge}
)</code></pre><p>Extents.intersects(to<em>extent(edges</em>a), to<em>extent(edges</em>b)) || return false</p><pre><code class="language-julia hljs">    for edge_a in edges_a
        for edge_b in edges_b
            _edge_intersects(edge_a, edge_b) &amp;&amp; return true
        end
    end
    return false
end</code></pre><p>Checks if two edges intersect</p><pre><code class="language-julia hljs">function _edge_intersects(edge_a::Edge, edge_b::Edge)
    meet_type = ExactPredicates.meet(edge_a..., edge_b...)
    return meet_type == 0 || meet_type == 1
end</code></pre><p>Checks if point is on a segment</p><pre><code class="language-julia hljs">function _point_on_seg(point, start, stop)</code></pre><p>Parse out points</p><pre><code class="language-julia hljs">    x, y = GI.x(point), GI.y(point)
    x1, y1 = GI.x(start), GI.y(start)
    x2, y2 = GI.x(stop), GI.y(stop)
    Δxl = x2 - x1
    Δyl = y2 - y1</code></pre><p>Determine if point is on segment</p><pre><code class="language-julia hljs">    cross = (x - x1) * Δyl - (y - y1) * Δxl
    if cross == 0  # point is on line extending to infinity</code></pre><p>is line between endpoints</p><pre><code class="language-julia hljs">        if abs(Δxl) &gt;= abs(Δyl)  # is line between endpoints
            return Δxl &gt; 0 ? x1 &lt;= x &lt;= x2 : x2 &lt;= x &lt;= x1
        else
            return Δyl &gt; 0 ? y1 &lt;= y &lt;= y2 : y2 &lt;= y &lt;= y1
        end
    end
    return false
end</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../intersects/">« Intersection checks</a><a class="docs-footer-nextpage" href="../touches/">Touches »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 12 January 2024 21:29">Friday 12 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
