import{_ as t,c as a,o,az as i}from"./chunks/framework.Dl3dp2vx.js";const d=JSON.parse('{"title":"How to write fast code","description":"","frontmatter":{},"headers":[],"relativePath":"explanations/performance.md","filePath":"explanations/performance.md","lastUpdated":null}'),r={name:"explanations/performance.md"};function s(l,e,n,c,h,p){return o(),a("div",null,[...e[0]||(e[0]=[i('<h1 id="How-to-write-fast-code" tabindex="-1">How to write fast code <a class="header-anchor" href="#How-to-write-fast-code" aria-label="Permalink to &quot;How to write fast code {#How-to-write-fast-code}&quot;">​</a></h1><p>In the GeoInterface ecosystem and GeometryOps specifically, there are a few tricks that can help you keep your code fast and allocation free.</p><h2 id="Always-propagate-compile-time-information" tabindex="-1">Always propagate compile-time information <a class="header-anchor" href="#Always-propagate-compile-time-information" aria-label="Permalink to &quot;Always propagate compile-time information {#Always-propagate-compile-time-information}&quot;">​</a></h2><p>The first time you call <code>trait</code> should be the last time you call <code>trait</code> on that geometry. Otherwise - propagate that trait down the stack!</p><p>If you don&#39;t, then the compiler loses track of it, and when it finds it again, it has to allocate to perform a dynamic dispatch. This is pretty slow and can cause a 3x (or much much larger) slowdown in your code.</p><p>Things like the <a href="/GeometryOps.jl/previews/PR339/api#GeometryOpsCore.Applicator"><code>Applicator</code></a>s and especially the <a href="/GeometryOps.jl/previews/PR339/api#GeometryOpsCore.WithTrait"><code>WithTrait</code></a> applicator can help here.</p><p>Similarly, you&#39;ll notice a pattern where we pass a floating point type down the chain. This is done for type stability as well. If GeoInterface gets a <code>coordtype</code> in future then it&#39;ll default to <code>float(coordtype(geom))</code>, but for now we fix it at f64 and let the user change it if they want. This lets us avoid all the issues with &quot;oh but I have a float32 geometry or a bigfloat geometry or something&quot;.</p><h2 id="Try-not-to-allocate-unless-necessary" tabindex="-1">Try not to allocate unless necessary <a class="header-anchor" href="#Try-not-to-allocate-unless-necessary" aria-label="Permalink to &quot;Try not to allocate unless necessary {#Try-not-to-allocate-unless-necessary}&quot;">​</a></h2><p>There are a lot of algorithms that seem simple to implement with some <code>collect</code>s. Try to skip that if possible, and use GeoInterface constructs like <code>getgeom</code>, <code>getpoint</code>, and <code>getring</code>, which are faster anyway.</p><h2 id="Analyse-your-code-using-Julia-tools" tabindex="-1">Analyse your code using Julia tools <a class="header-anchor" href="#Analyse-your-code-using-Julia-tools" aria-label="Permalink to &quot;Analyse your code using Julia tools {#Analyse-your-code-using-Julia-tools}&quot;">​</a></h2><p><a href="https://github.com/timholy/ProfileView.jl" target="_blank" rel="noreferrer"><strong>ProfileView.jl</strong></a> and <a href="https://github.com/Cthulhu.jl" target="_blank" rel="noreferrer"><strong>Cthulhu.jl</strong></a> work together very well to diagnose and fix type instability. <a href="https://github.com/aviatesk/JET.jl" target="_blank" rel="noreferrer"><strong>JET.jl</strong></a> is also good here.</p><p><a href="https://github.com/KristofferC/TimerOutputs.jl" target="_blank" rel="noreferrer"><strong>TimerOutputs.jl</strong></a> is excellent for characterizing where your time is being spent and which parts of your function you should focus on optimizing. Always use TimerOutputs before hyperoptimizing - you don&#39;t usually want to halve the cost of a function which contributes 1% of your runtime!</p><h2 id="Use-statically-sized,-immutable-types-where-you-can" tabindex="-1">Use statically sized, immutable types where you can <a class="header-anchor" href="#Use-statically-sized,-immutable-types-where-you-can" aria-label="Permalink to &quot;Use statically sized, immutable types where you can {#Use-statically-sized,-immutable-types-where-you-can}&quot;">​</a></h2><p>Static, immutable types are very good because they can be inlined and do not allocate. But this isn&#39;t a taboo against mutables by any means. Sometimes rolling your own stack (which allocates) is substantially faster than recursion (which technically doesn&#39;t).</p><p>If you have a type which you don&#39;t know the size of, and which you believe is completely random and unpredictable at compile time, pay the cost and make it a vector instead of forcing type instability. This applies to tuples etc.</p>',15)])])}const y=t(r,[["render",s]]);export{d as __pageData,y as default};
