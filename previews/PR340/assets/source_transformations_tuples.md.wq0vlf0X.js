import{_ as i,c as a,o as n,az as e}from"./chunks/framework.DAkXNBzo.js";const F=JSON.parse('{"title":"Tuple conversion","description":"","frontmatter":{},"headers":[],"relativePath":"source/transformations/tuples.md","filePath":"source/transformations/tuples.md","lastUpdated":null}'),t={name:"source/transformations/tuples.md"};function l(p,s,h,k,r,o){return n(),a("div",null,[...s[0]||(s[0]=[e('<h1 id="Tuple-conversion" tabindex="-1">Tuple conversion <a class="header-anchor" href="#Tuple-conversion" aria-label="Permalink to &quot;Tuple conversion {#Tuple-conversion}&quot;">â€‹</a></h1><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    tuples(obj)</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Convert all points in `obj` to `Tuple`s, wherever the are nested.</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Returns a similar object or collection of objects using GeoInterface.jl</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">geometries wrapping `Tuple` points.</span></span></code></pre></div><p>Keywords</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `threaded`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`true`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> or </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`false`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. Whether to use multithreading. Defaults to </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`false`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `crs`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: The CRS to attach to geometries. Defaults to </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`nothing`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> `calc_extent`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`true`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> or </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`false`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">. Whether to calculate the extent. Defaults to </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`true`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&quot;&quot;</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">function tuples(geom, ::Type{T} = Float64; calc_extent = true, kw...) where T</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    if _is3d(geom)</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        return apply(PointTrait(), geom; calc_extent, kw...) do p</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            (T(GI.x(p)), T(GI.y(p)), T(GI.z(p)))</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        end</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    else</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        return apply(PointTrait(), geom; calc_extent, kw...) do p</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">            (T(GI.x(p)), T(GI.y(p)))</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">        end</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    end</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">end</span></span></code></pre></div><hr><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl" target="_blank" rel="noreferrer">Literate.jl</a>.</em></p>',6)])])}const c=i(t,[["render",l]]);export{F as __pageData,c as default};
