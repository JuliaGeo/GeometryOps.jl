<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · GeometryOps.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://asinghvi17.github.io/GeometryOps.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href><img src="assets/logo.png" alt="GeometryOps.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href>GeometryOps.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li><li><span class="tocitem">Source code</span><ul><li><a class="tocitem" href="source/GeometryOps/">GeometryOps.jl</a></li><li><a class="tocitem" href="source/primitives/">Primitive functions</a></li><li><a class="tocitem" href="source/utils/">Utility functions</a></li><li><a class="tocitem" href="source/methods/barycentric/">Barycentric coordinates</a></li><li><a class="tocitem" href="source/methods/bools/">Boolean conditions</a></li><li><a class="tocitem" href="source/methods/centroid/">Centroid</a></li><li><a class="tocitem" href="source/methods/contains/">Containment</a></li><li><a class="tocitem" href="source/methods/crosses/">Crossing checks</a></li><li><a class="tocitem" href="source/methods/disjoint/">Disjointness checks</a></li><li><a class="tocitem" href="source/methods/equals/">Equals</a></li><li><a class="tocitem" href="source/methods/intersects/">Intersection checks</a></li><li><a class="tocitem" href="source/methods/overlaps/">Overlaps</a></li><li><a class="tocitem" href="source/methods/polygonize/">Polygonizing raster data</a></li><li><a class="tocitem" href="source/methods/signed_area/">Signed area</a></li><li><a class="tocitem" href="source/methods/signed_distance/">Signed distance</a></li><li><a class="tocitem" href="source/methods/within/">Containment/withinness</a></li><li><a class="tocitem" href="source/transformations/extent/">-</a></li><li><a class="tocitem" href="source/transformations/flip/">Coordinate flipping</a></li><li><a class="tocitem" href="source/transformations/reproject/">Geometry reprojection</a></li><li><a class="tocitem" href="source/transformations/simplify/">Geometry simplification</a></li><li><a class="tocitem" href="source/transformations/tuples/">Tuple conversion</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/asinghvi17/GeometryOps.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="GeometryOps"><a class="docs-heading-anchor" href="#GeometryOps">GeometryOps</a><a id="GeometryOps-1"></a><a class="docs-heading-anchor-permalink" href="#GeometryOps" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/asinghvi17/GeometryOps.jl">GeometryOps</a>.</p><ul><li><a href="#GeometryOps.AbstractBarycentricCoordinateMethod"><code>GeometryOps.AbstractBarycentricCoordinateMethod</code></a></li><li><a href="#GeometryOps.DouglasPeucker"><code>GeometryOps.DouglasPeucker</code></a></li><li><a href="#GeometryOps.MeanValue"><code>GeometryOps.MeanValue</code></a></li><li><a href="#GeometryOps.RadialDistance"><code>GeometryOps.RadialDistance</code></a></li><li><a href="#GeometryOps.SimplifyAlg"><code>GeometryOps.SimplifyAlg</code></a></li><li><a href="#GeometryOps.VisvalingamWhyatt"><code>GeometryOps.VisvalingamWhyatt</code></a></li><li><a href="#GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps._det</code></a></li><li><a href="#GeometryOps._distance-Tuple{Any, Any, Any}"><code>GeometryOps._distance</code></a></li><li><a href="#GeometryOps._equals_curves-NTuple{4, Any}"><code>GeometryOps._equals_curves</code></a></li><li><a href="#GeometryOps._intersection_point-Tuple{Tuple, Tuple}"><code>GeometryOps._intersection_point</code></a></li><li><a href="#GeometryOps._line_intersects-Tuple{Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}}"><code>GeometryOps._line_intersects</code></a></li><li><a href="#GeometryOps._line_intersects-Tuple{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}"><code>GeometryOps._line_intersects</code></a></li><li><a href="#GeometryOps._overlaps-Tuple{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}"><code>GeometryOps._overlaps</code></a></li><li><a href="#GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target"><code>GeometryOps.apply</code></a></li><li><a href="#GeometryOps.centroid-Tuple{Any, Any}"><code>GeometryOps.centroid</code></a></li><li><a href="#GeometryOps.centroid-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid</code></a></li><li><a href="#GeometryOps.centroid-Tuple{Any}"><code>GeometryOps.centroid</code></a></li><li><a href="#GeometryOps.centroid_and_area-Tuple{Any}"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_area-Tuple{GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_area-Tuple{GeoInterface.PolygonTrait, Any}"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_area-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_length-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid_and_length</code></a></li><li><a href="#GeometryOps.centroid_and_length-Tuple{Any}"><code>GeometryOps.centroid_and_length</code></a></li><li><a href="#GeometryOps.contains-Tuple{Any, Any}"><code>GeometryOps.contains</code></a></li><li><a href="#GeometryOps.crosses-Tuple{Any, Any}"><code>GeometryOps.crosses</code></a></li><li><a href="#GeometryOps.disjoint-Tuple{Any, Any}"><code>GeometryOps.disjoint</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-NTuple{4, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{Any, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Union{Tuple{T}, Tuple{T, Any, T, Any}} where T"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.PointTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, GeoInterface.LinearRingTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, GeoInterface.LinearRingTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.PointTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target&lt;:GeoInterface.AbstractTrait"><code>GeometryOps.flatten</code></a></li><li><a href="#GeometryOps.flip-Tuple{Any}"><code>GeometryOps.flip</code></a></li><li><a href="#GeometryOps.get_contours-Tuple{AbstractMatrix}"><code>GeometryOps.get_contours</code></a></li><li><a href="#GeometryOps.intersection-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.intersection</code></a></li><li><a href="#GeometryOps.intersection-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.intersection</code></a></li><li><a href="#GeometryOps.intersection-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.intersection</code></a></li><li><a href="#GeometryOps.intersection-Tuple{Any, Any}"><code>GeometryOps.intersection</code></a></li><li><a href="#GeometryOps.intersection_points-Tuple{Any, Any}"><code>GeometryOps.intersection_points</code></a></li><li><a href="#GeometryOps.intersection_points-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.intersection_points</code></a></li><li><a href="#GeometryOps.intersects-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.intersects</code></a></li><li><a href="#GeometryOps.intersects-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.intersects</code></a></li><li><a href="#GeometryOps.intersects-Tuple{Any, Any}"><code>GeometryOps.intersects</code></a></li><li><a href="#GeometryOps.isclockwise-Tuple{Any}"><code>GeometryOps.isclockwise</code></a></li><li><a href="#GeometryOps.isconcave-Tuple{Any}"><code>GeometryOps.isconcave</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{Any, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.point_in_polygon-Tuple{Any, Any}"><code>GeometryOps.point_in_polygon</code></a></li><li><a href="#GeometryOps.point_on_line-Tuple{Any, Any}"><code>GeometryOps.point_on_line</code></a></li><li><a href="#GeometryOps.polygon_to_line-Tuple{Any}"><code>GeometryOps.polygon_to_line</code></a></li><li><a href="#GeometryOps.polygonize-Tuple{AbstractMatrix}"><code>GeometryOps.polygonize</code></a></li><li><a href="#GeometryOps.rebuild-Tuple{Any, Any}"><code>GeometryOps.rebuild</code></a></li><li><a href="#GeometryOps.reconstruct-Tuple{Any, Any}"><code>GeometryOps.reconstruct</code></a></li><li><a href="#GeometryOps.reproject-Tuple{Any}"><code>GeometryOps.reproject</code></a></li><li><a href="#GeometryOps.signed_area-Tuple{Any}"><code>GeometryOps.signed_area</code></a></li><li><a href="#GeometryOps.signed_distance-Tuple{Any, Any, Any}"><code>GeometryOps.signed_distance</code></a></li><li><a href="#GeometryOps.simplify-Tuple{Any}"><code>GeometryOps.simplify</code></a></li><li><a href="#GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps.t_value</code></a></li><li><a href="#GeometryOps.to_edges-Tuple{Any}"><code>GeometryOps.to_edges</code></a></li><li><a href="#GeometryOps.tuples-Tuple{Any}"><code>GeometryOps.tuples</code></a></li><li><a href="#GeometryOps.unwrap"><code>GeometryOps.unwrap</code></a></li><li><a href="#GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT&lt;:Real"><code>GeometryOps.weighted_mean</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.AbstractBarycentricCoordinateMethod" href="#GeometryOps.AbstractBarycentricCoordinateMethod"><code>GeometryOps.AbstractBarycentricCoordinateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractBarycentricCoordinateMethod</code></pre><p>Abstract supertype for barycentric coordinate methods.   The subtypes may serve as dispatch types, or may cache  some information about the target polygon.  </p><p><strong>API</strong></p><p>The following methods must be implemented for all subtypes:</p><ul><li><code>barycentric_coordinates!(λs::Vector{&lt;: Real}, method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, point::Point{2, T2})</code></li><li><code>barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, values::Vector{V}, point::Point{2, T2})::V</code></li><li><code>barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, interiors::Vector{&lt;: Vector{&lt;: Point{2, T1}}} values::Vector{V}, point::Point{2, T2})::V</code></li></ul><p>The rest of the methods will be implemented in terms of these, and have efficient dispatches for broadcasting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/barycentric.jl#L112-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.DouglasPeucker" href="#GeometryOps.DouglasPeucker"><code>GeometryOps.DouglasPeucker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DouglasPeucker &lt;: SimplifyAlg

DouglasPeucker(; number, ratio, tol)</code></pre><p>Simplifies geometries by removing points below <code>tol</code> distance from the line between its neighboring points.</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum distance a point will be from the line   joining its neighboring points.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/transformations/simplify.jl#L177-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.MeanValue" href="#GeometryOps.MeanValue"><code>GeometryOps.MeanValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeanValue() &lt;: AbstractBarycentricCoordinateMethod</code></pre><p>This method calculates barycentric coordinates using the mean value method.</p><p><strong>References</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/barycentric.jl#L218-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.RadialDistance" href="#GeometryOps.RadialDistance"><code>GeometryOps.RadialDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialDistance &lt;: SimplifyAlg</code></pre><p>Simplifies geometries by removing points less than <code>tol</code> distance from the line between its neighboring points.</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum distance between points.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/transformations/simplify.jl#L133-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.SimplifyAlg" href="#GeometryOps.SimplifyAlg"><code>GeometryOps.SimplifyAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type SimplifyAlg</code></pre><p>Abstract type for simplification algorithms.</p><p><strong>API</strong></p><p>For now, the algorithm must hold the <code>number</code>, <code>ratio</code> and <code>tol</code> properties.  </p><p>Simplification algorithm types can hook into the interface by implementing  the <code>_simplify(trait, alg, geom)</code> methods for whichever traits are necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/transformations/simplify.jl#L9-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.VisvalingamWhyatt" href="#GeometryOps.VisvalingamWhyatt"><code>GeometryOps.VisvalingamWhyatt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VisvalingamWhyatt &lt;: SimplifyAlg

VisvalingamWhyatt(; kw...)</code></pre><p>Simplifies geometries by removing points below <code>tol</code> distance from the line between its neighboring points.</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum area of a triangle made with a point and   its neighboring points.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/transformations/simplify.jl#L234-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1&lt;:Real, T2&lt;:Real}" href="#GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps._det</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_det(s1::Point2{T1}, s2::Point2{T2}) where {T1 &lt;: Real, T2 &lt;: Real}</code></pre><p>Returns the determinant of the matrix formed by <code>hcat</code>&#39;ing two points <code>s1</code> and <code>s2</code>.</p><p>Specifically, this is: </p><pre><code class="language-julia hljs">s1[1] * s2[2] - s1[2] * s2[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/barycentric.jl#L232-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._distance-Tuple{Any, Any, Any}" href="#GeometryOps._distance-Tuple{Any, Any, Any}"><code>GeometryOps._distance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Distance from p0 to the line segment formed by p1 and p2.  Implementation from Turf.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/signed_distance.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._equals_curves-NTuple{4, Any}" href="#GeometryOps._equals_curves-NTuple{4, Any}"><code>GeometryOps._equals_curves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_equals_curves(c1, c2, closed_type1, closed_type2)::Bool</code></pre><p>Two curves are equal if they share the same set of point, representing the same geometry. Both curves must must be composed of the same set of points, however, they do not have to wind in the same direction, or start on the same point to be equivalent. Inputs:     c1 first geometry     c2 second geometry     closed<em>type1::Bool true if c1 is closed by definition (polygon, linear ring)     closed</em>type2::Bool true if c2 is closed by definition (polygon, linear ring)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L143-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._intersection_point-Tuple{Tuple, Tuple}" href="#GeometryOps._intersection_point-Tuple{Tuple, Tuple}"><code>GeometryOps._intersection_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_intersection_point(
    (a1, a2)::Tuple,
    (b1, b2)::Tuple,
)</code></pre><p>Calculates the intersection point between two lines if it exists, and as if the line extended to infinity, and the fractional component of each line from the initial end point to the intersection point. Inputs:     (a1, a2)::Tuple{Tuple{::Real, ::Real}, Tuple{::Real, ::Real}} first line     (b1, b2)::Tuple{Tuple{::Real, ::Real}, Tuple{::Real, ::Real}} second line Outputs:     (x, y)::Tuple{::Real, ::Real} intersection point     (t, u)::Tuple{::Real, ::Real} fractional length of lines to intersection     Both are ::Nothing if point doesn&#39;t exist!</p><p>Calculation derivation can be found here:     https://stackoverflow.com/questions/563198/</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/intersects.jl#L309-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._line_intersects-Tuple{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}" href="#GeometryOps._line_intersects-Tuple{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}"><code>GeometryOps._line_intersects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_line_intersects(
    edge_a::Edge,
    edge_b::Edge,
)::Bool</code></pre><p>Returns true if there is at least one intersection between two edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/intersects.jl#L132-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._line_intersects-Tuple{Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}}" href="#GeometryOps._line_intersects-Tuple{Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}, Vector{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}}"><code>GeometryOps._line_intersects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_line_intersects(
    edges_a::Vector{Edge},
    edges_b::Vector{Edge}
)::Bool</code></pre><p>Returns true if there is at least one intersection between edges within the two lists of edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/intersects.jl#L110-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps._overlaps-Tuple{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}" href="#GeometryOps._overlaps-Tuple{Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}}"><code>GeometryOps._overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_overlaps(
    (a1, a2)::Edge,
    (b1, b2)::Edge
)::Bool</code></pre><p>If the edges overlap, meaning that they are colinear but each have one endpoint outside of the other edge, return true. Else false. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/overlaps.jl#L214-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target" href="#GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target"><code>GeometryOps.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply(f, target::Type{&lt;:AbstractTrait}, obj; crs)</code></pre><p>Reconstruct a geometry or feature using the function <code>f</code> on the <code>target</code> trait.</p><p><code>f(target_geom) =&gt; x</code> where <code>x</code> also has the <code>target</code> trait, or an equivalent.</p><p>The result is an functionally similar geometry with values depending on <code>f</code></p><p><strong>Flipped point the order in any feature or geometry, or iterables of either:</strong></p><p>```juia import GeoInterface as GI import GeometryOps as GO geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]),                     GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])])</p><p>flipped_geom = GO.apply(GI.PointTrait, geom) do p     (GI.y(p), GI.x(p)) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/primitives.jl#L6-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid-Tuple{Any, Any}" href="#GeometryOps.centroid-Tuple{Any, Any}"><code>GeometryOps.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(trait, geom)::Tuple{T, T}</code></pre><p>Returns the centroid of a polygon or multipolygon, which is calculated by weighting edges by their <code>area component</code> by convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/centroid.jl#L76-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid-Tuple{Any}" href="#GeometryOps.centroid-Tuple{Any}"><code>GeometryOps.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(geom)::Tuple{T, T}</code></pre><p>Returns the centroid of a given line segment, linear ring, polygon, or mutlipolygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/centroid.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}" href="#GeometryOps.centroid-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(
    trait::Union{GI.LineStringTrait, GI.LinearRingTrait},
    geom,
)::Tuple{T, T}</code></pre><p>Returns the centroid of a line string or linear ring, which is calculated by weighting line segments by their length by convention.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/centroid.jl#L62-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_area-Tuple{Any}" href="#GeometryOps.centroid_and_area-Tuple{Any}"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(
    ::Union{GI.LineStringTrait, GI.LinearRingTrait}, 
    geom,
)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given geom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/centroid.jl#L92-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_area-Tuple{GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.centroid_and_area-Tuple{GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(::GI.MultiPolygonTrait, geom)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given multipolygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/centroid.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_area-Tuple{GeoInterface.PolygonTrait, Any}" href="#GeometryOps.centroid_and_area-Tuple{GeoInterface.PolygonTrait, Any}"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(::GI.PolygonTrait, geom)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/centroid.jl#L181-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_area-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}" href="#GeometryOps.centroid_and_area-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(
    ::Union{GI.LineStringTrait, GI.LinearRingTrait},
    geom,
)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given a line string or a linear ring. Note that this is only valid if the line segment or linear ring is closed. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/centroid.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_length-Tuple{Any}" href="#GeometryOps.centroid_and_length-Tuple{Any}"><code>GeometryOps.centroid_and_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_length(geom)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and length of a given line/ring. Note this is only valid for line strings and linear rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/centroid.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.centroid_and_length-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}" href="#GeometryOps.centroid_and_length-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LinearRingTrait}, Any}"><code>GeometryOps.centroid_and_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_length(geom)::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and length of a given line/ring. Note this is only valid for line strings and linear rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/centroid.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.contains-Tuple{Any, Any}" href="#GeometryOps.contains-Tuple{Any, Any}"><code>GeometryOps.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contains(ft1::AbstractGeometry, ft2::AbstractGeometry)::Bool</code></pre><p>Return true if the second geometry is completely contained by the first geometry. The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b) must not intersect the exterior of the primary (geometry a). <code>contains</code> returns the exact opposite result of <code>within</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
line = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
point = (1, 2)

GO.contains(line, point)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/contains.jl#L5-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.crosses-Tuple{Any, Any}" href="#GeometryOps.crosses-Tuple{Any, Any}"><code>GeometryOps.crosses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> crosses(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the intersection results in a geometry whose dimension is one less than the maximum dimension of the two source geometries and the intersection set is interior to both source geometries.</p><p>TODO: broken</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

line1 = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
line2 = GI.LineString([(-2, 2), (4, 2)])

GO.crosses(line1, line2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/crosses.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.disjoint-Tuple{Any, Any}" href="#GeometryOps.disjoint-Tuple{Any, Any}"><code>GeometryOps.disjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disjoint(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the intersection of the two geometries is an empty set.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

poly = GI.Polygon([[(-1, 2), (3, 2), (3, 3), (-1, 3), (-1, 2)]])
point = (1, 1)
GO.disjoint(poly, point)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/disjoint.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-NTuple{4, Any}" href="#GeometryOps.equals-NTuple{4, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(trait_a, geom_a, trait_b, geom_b)</code></pre><p>Two geometries which are not of the same type cannot be equal so they always return false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{Any, Any}" href="#GeometryOps.equals-Tuple{Any, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(geom1, geom2)::Bool</code></pre><p>Compare two Geometries return true if they are the same geometry.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
poly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])
poly2 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])

GO.equals(poly1, poly2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L51-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, GeoInterface.LinearRingTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, GeoInterface.LinearRingTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(
    ::GI.LinearRingTrait, l1,
    ::GI.LinearRingTrait, l2,
)::Bool</code></pre><p>Two linear rings are equal if they share the same set of points going along the curve. Note that rings are closed by definition, so they can have, but don&#39;t need, a repeated last point to be equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L249-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(
    ::GI.LinearRingTrait, l1,
    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,
)::Bool</code></pre><p>A linear ring and a line/linestring are equal if they share the same set of points going along the curve. Note that lines aren&#39;t closed by defintion, but rings are, so the line must have a repeated last point to be equal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L234-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.MultiPointTrait, mp1, ::GI.MultiPointTrait, mp2)::Bool</code></pre><p>Two multipoints are equal if they share the same set of points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.PointTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.PointTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.MultiPointTrait, mp1, ::GI.PointTrait, p2)::Bool</code></pre><p>A point and a multipoint are equal if the multipoint is composed of a single point that is equivalent to the given point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool</code></pre><p>Two multipolygons are equal if they share the same set of polygons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L314-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.MultiPolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool</code></pre><p>A polygon and a multipolygon are equal if the multipolygon is composed of a single polygon that is equivalent to the given polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L305-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.MultiPointTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PointTrait, p1, ::GI.MultiPointTrait, mp2)::Bool</code></pre><p>A point and a multipoint are equal if the multipoint is composed of a single point that is equivalent to the given point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.PointTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.PointTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PointTrait, p1, ::GI.PointTrait, p2)::Bool</code></pre><p>Two points are the same if they have the same x and y (and z if 3D) coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PolygonTrait, geom_a, ::GI.MultiPolygonTrait, geom_b)::Bool</code></pre><p>A polygon and a multipolygon are equal if the multipolygon is composed of a single polygon that is equivalent to the given polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L294-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool</code></pre><p>Two polygons are equal if they share the same exterior edge and holes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, GeoInterface.LinearRingTrait, Any}" href="#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, GeoInterface.LinearRingTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(
    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,
    ::GI.LinearRingTrait, l2,
)::Bool</code></pre><p>A line/linestring and a linear ring are equal if they share the same set of points going along the curve. Note that lines aren&#39;t closed by defintion, but rings are, so the line must have a repeated last point to be equal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L219-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}" href="#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(
    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,
    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,
)::Bool</code></pre><p>Two lines/linestrings are equal if they share the same set of points going along the curve. Note that lines/linestrings aren&#39;t closed by defintion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L205-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.equals-Union{Tuple{T}, Tuple{T, Any, T, Any}} where T" href="#GeometryOps.equals-Union{Tuple{T}, Tuple{T, Any, T, Any}} where T"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::T, geom_a, ::T, geom_b)::Bool</code></pre><p>Two geometries of the same type, which don&#39;t have a equals function to dispatch off of should throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/equals.jl#L72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target&lt;:GeoInterface.AbstractTrait" href="#GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target&lt;:GeoInterface.AbstractTrait"><code>GeometryOps.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flatten(target::Type{&lt;:GI.AbstractTrait}, geom)</code></pre><p>Lazily flatten any geometry, feature or iterator of geometries or features so that objects with the specified trait are returned by the iterator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/primitives.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.flip-Tuple{Any}" href="#GeometryOps.flip-Tuple{Any}"><code>GeometryOps.flip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flip(obj)</code></pre><p>Swap all of the x and y coordinates in obj, otherwise keeping the original structure (but not necessarily the original type).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/transformations/flip.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.get_contours-Tuple{AbstractMatrix}" href="#GeometryOps.get_contours-Tuple{AbstractMatrix}"><code>GeometryOps.get_contours</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_contours(A::AbstractMatrix)</p><p>Returns contours as vectors of <code>CartesianIndex</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/polygonize.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersection-Tuple{Any, Any}" href="#GeometryOps.intersection-Tuple{Any, Any}"><code>GeometryOps.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(geom_a, geom_b)::Union{Tuple{::Real, ::Real}, ::Nothing}</code></pre><p>Return an intersection point between two geometries. Return nothing if none are found. Else, the return type depends on the input. It will be a union between: a point, a line, a linear ring, a polygon, or a multipolygon</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

line1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])
line2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])
GO.intersection(line1, line2)

# output
(125.58375366067547, -14.83572303404496)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/intersects.jl#L145-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersection-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}" href="#GeometryOps.intersection-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(
    ::GI.AbstractTrait, geom_a,
    ::GI.AbstractTrait, geom_b,
)::Union{
    ::Vector{Vector{Tuple{::Real, ::Real}}}, # is this a good return type?
    ::Nothing
}</code></pre><p>Calculates the intersection between two line segments. Return nothing if there isn&#39;t one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/intersects.jl#L219-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersection-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}" href="#GeometryOps.intersection-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(
    ::GI.LineTrait, line_a,
    ::GI.LineTrait, line_b,
)::Union{
    ::Tuple{::Real, ::Real},
    ::Nothing
}</code></pre><p>Calculates the intersection between two line segments. Return nothing if there isn&#39;t one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/intersects.jl#L168-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersection-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.intersection-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(
    ::GI.PolygonTrait, poly_a,
    ::GI.PolygonTrait, poly_b,
)::Union{
    ::Vector{Vector{Tuple{::Real, ::Real}}}, # is this a good return type?
    ::Nothing
}</code></pre><p>Calculates the intersection between two line segments. Return nothing if there isn&#39;t one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/intersects.jl#L202-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersection_points-Tuple{Any, Any}" href="#GeometryOps.intersection_points-Tuple{Any, Any}"><code>GeometryOps.intersection_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection_points(
    geom_a,
    geom_b,
)::Union{
    ::Vector{::Tuple{::Real, ::Real}},
    ::Nothing,
}</code></pre><p>Return a list of intersection points between two geometries. If no intersection point was possible given geometry extents, return nothing. If none are found, return an empty list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/intersects.jl#L242-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersection_points-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}" href="#GeometryOps.intersection_points-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.intersection_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection_points(
    ::GI.AbstractTrait, geom_a,
    ::GI.AbstractTrait, geom_b,
)::Union{
    ::Vector{::Tuple{::Real, ::Real}},
    ::Nothing,
}</code></pre><p>Calculates the list of intersection points between two geometries, inlcuding line segments, line strings, linear rings, polygons, and multipolygons. If no intersection points were possible given geometry extents, return nothing. If none are found, return an empty list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/intersects.jl#L258-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersects-Tuple{Any, Any}" href="#GeometryOps.intersects-Tuple{Any, Any}"><code>GeometryOps.intersects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersects(geom1, geom2)::Bool</code></pre><p>Check if two geometries intersect, returning true if so and false otherwise.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

line1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])
line2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])
GO.intersects(line1, line2)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/intersects.jl#L55-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersects-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}" href="#GeometryOps.intersects-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.intersects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersects(::GI.AbstractTrait, a, ::GI.AbstractTrait, b)::Bool</code></pre><p>Returns true if two geometries intersect with one another and false otherwise. For all geometries but lines, convert the geometry to a list of edges and cross compare the edges for intersections.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/intersects.jl#L94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.intersects-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}" href="#GeometryOps.intersects-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.intersects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersects(::GI.LineTrait, a, ::GI.LineTrait, b)::Bool</code></pre><p>Returns true if two line segments intersect and false otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/intersects.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.isclockwise-Tuple{Any}" href="#GeometryOps.isclockwise-Tuple{Any}"><code>GeometryOps.isclockwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isclockwise(line::Union{LineString, Vector{Position}})::Bool</code></pre><p>Take a ring and return true or false whether or not the ring is clockwise or counter-clockwise.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

ring = GI.LinearRing([(0, 0), (1, 1), (1, 0), (0, 0)])
GO.isclockwise(ring)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/bools.jl#L11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.isconcave-Tuple{Any}" href="#GeometryOps.isconcave-Tuple{Any}"><code>GeometryOps.isconcave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isconcave(poly::Polygon)::Bool</code></pre><p>Take a polygon and return true or false as to whether it is concave or not.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

poly = GI.Polygon([[(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]])
GO.isconcave(poly)

# output
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/bools.jl#L43-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{Any, Any}" href="#GeometryOps.overlaps-Tuple{Any, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(geom1, geom2)::Bool</code></pre><p>Compare two Geometries of the same dimension and return true if their intersection set results in a geometry different from both but of the same dimension. This means one geometry cannot be within or contain the other and they cannot be equal</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
poly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])
poly2 = GI.Polygon([[(1,1), (1,6), (6,6), (6,1), (1,1)]])

GO.overlaps(poly1, poly2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/overlaps.jl#L52-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(::GI.AbstractTrait, geom1, ::GI.AbstractTrait, geom2)::Bool</code></pre><p>For any non-specified pair, all have non-matching dimensions, return false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/overlaps.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(::GI.LineTrait, line1, ::GI.LineTrait, line)::Bool</code></pre><p>If the lines overlap, meaning that they are colinear but each have one endpoint outside of the other line, return true. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/overlaps.jl#L115-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.MultiPointTrait, points1,
    ::GI.MultiPointTrait, points2,
)::Bool</code></pre><p>If the multipoints overlap, meaning some, but not all, of the points within the multipoints are shared, return true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/overlaps.jl#L85-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.MultiPolygonTrait, polys1,
    ::GI.MultiPolygonTrait, polys2,
)::Bool</code></pre><p>Return true if at least one pair of polygons from multipolygons overlap. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/overlaps.jl#L195-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.MultiPolygonTrait, polys1,
    ::GI.PolygonTrait, poly2,
)::Bool</code></pre><p>Return true if polygon overlaps with at least one of the polygons within the multipolygon. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/overlaps.jl#L183-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.PolygonTrait, poly1,
    ::GI.MultiPolygonTrait, polys2,
)::Bool</code></pre><p>Return true if polygon overlaps with at least one of the polygons within the multipolygon. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/overlaps.jl#L164-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    trait_a::GI.PolygonTrait, poly_a,
    trait_b::GI.PolygonTrait, poly_b,
)::Bool</code></pre><p>If the two polygons intersect with one another, but are not equal, return true. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/overlaps.jl#L146-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any}" href="#GeometryOps.overlaps-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::Union{GI.LineStringTrait, GI.LinearRing}, line1,
    ::Union{GI.LineStringTrait, GI.LinearRing}, line2,
)::Bool</code></pre><p>If the curves overlap, meaning that at least one edge of each curve overlaps, return true. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/overlaps.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.point_in_polygon-Tuple{Any, Any}" href="#GeometryOps.point_in_polygon-Tuple{Any, Any}"><code>GeometryOps.point_in_polygon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_in_polygon(point::Point, polygon::Union{Polygon, MultiPolygon}, ignore_boundary::Bool=false)::Bool</code></pre><p>Take a Point and a Polygon and determine if the point resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

point = (-77.0, 44.0)
poly = GI.Polygon([[(-81, 41), (-81, 47), (-72, 47), (-72, 41), (-81, 41)]])
GO.point_in_polygon(point, poly)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/bools.jl#L233-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.point_on_line-Tuple{Any, Any}" href="#GeometryOps.point_on_line-Tuple{Any, Any}"><code>GeometryOps.point_on_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">point_on_line(point::Point, line::LineString; ignore_end_vertices::Bool=false)::Bool</code></pre><p>Return true if a point is on a line. Accept a optional parameter to ignore the start and end vertices of the linestring.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

point = (1, 1)
line = GI.LineString([(0, 0), (3, 3), (4, 4)])
GO.point_on_line(point, line)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/bools.jl#L133-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.polygon_to_line-Tuple{Any}" href="#GeometryOps.polygon_to_line-Tuple{Any}"><code>GeometryOps.polygon_to_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polygon_to_line(poly::Polygon)</code></pre><p>Converts a Polygon to LineString or MultiLineString</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

poly = GI.Polygon([[(-2.275543, 53.464547), (-2.275543, 53.489271), (-2.215118, 53.489271), (-2.215118, 53.464547), (-2.275543, 53.464547)]])
GO.polygon_to_line(poly)
# output
GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}([(-2.275543, 53.464547), (-2.275543, 53.489271), (-2.215118, 53.489271), (-2.215118, 53.464547), (-2.275543, 53.464547)], nothing, nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/utils.jl#L30-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.polygonize-Tuple{AbstractMatrix}" href="#GeometryOps.polygonize-Tuple{AbstractMatrix}"><code>GeometryOps.polygonize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polygonize(A; minpoints=10)
polygonize(xs, ys, A; minpoints=10)</code></pre><p>Convert matrix <code>A</code> to polygons.</p><p>If <code>xs</code> and <code>ys</code> are passed in they are used as the pixel center points.</p><p><strong>Keywords</strong></p><ul><li><code>minpoints</code>: ignore polygons with less than <code>minpoints</code> points. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/polygonize.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.rebuild-Tuple{Any, Any}" href="#GeometryOps.rebuild-Tuple{Any, Any}"><code>GeometryOps.rebuild</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rebuild(geom, child_geoms)</code></pre><p>Rebuild a geometry from child geometries.</p><p>By default geometries will be rebuilt as a GeoInterface.Wrappers  geometry, but <code>rebuild</code> can have methods added to it to dispatch on geometries from other packages and specify how to rebuild them.</p><p>(Maybe it should go into GeoInterface.jl)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/primitives.jl#L219-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.reconstruct-Tuple{Any, Any}" href="#GeometryOps.reconstruct-Tuple{Any, Any}"><code>GeometryOps.reconstruct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reconstruct(geom, components)</code></pre><p>Reconstruct <code>geom</code> from an iterable of component objects that match its structure.</p><p>All objects in <code>components</code> must have the same <code>GeoInterface.trait</code>.</p><p>Ususally used in combination with <code>flatten</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/primitives.jl#L162-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.reproject-Tuple{Any}" href="#GeometryOps.reproject-Tuple{Any}"><code>GeometryOps.reproject</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reproject(geometry; source_crs, target_crs, transform, always_xy, time)
reproject(geometry, source_crs, target_crs; always_xy, time)
reproject(geometry, transform; always_xy, time)</code></pre><p>Reproject any GeoInterface.jl compatible <code>geometry</code> from <code>source_crs</code> to <code>target_crs</code>.</p><p>The returned object will be constructed from <code>GeoInterface.WrapperGeometry</code> geometries, wrapping views of a <code>Vector{Proj.Point{D}}</code>, where <code>D</code> is the dimension.</p><p><strong>Arguments</strong></p><ul><li><code>geometry</code>: Any GeoInterface.jl compatible geometries.</li><li><code>source_crs</code>: the source coordinate referece system, as a GeoFormatTypes.jl object or a string.</li><li><code>target_crs</code>: the target coordinate referece system, as a GeoFormatTypes.jl object or a string.</li></ul><p>If these a passed as keywords, <code>transform</code> will take priority. Without it <code>target_crs</code> is always needed, and <code>source_crs</code> is needed if it is not retreivable from the geometry with <code>GeoInterface.crs(geometry)</code>.</p><p><strong>Keywords</strong></p><p>-<code>always_xy</code>: force x, y coordinate order, <code>true</code> by default.     <code>false</code> will expect and return points in the crs coordinate order. -<code>time</code>: the time for the coordinates. <code>Inf</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/transformations/reproject.jl#L11-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.signed_area-Tuple{Any}" href="#GeometryOps.signed_area-Tuple{Any}"><code>GeometryOps.signed_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signed_area(geom)::Real</code></pre><p>Returns the signed area of the geometry, based on winding order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/signed_area.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.signed_distance-Tuple{Any, Any, Any}" href="#GeometryOps.signed_distance-Tuple{Any, Any, Any}"><code>GeometryOps.signed_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signed_distance(geom, x::Real, y::Real)::Float64</code></pre><p>Calculates the signed distance from the geometry <code>geom</code> to the point defined by <code>(x, y)</code>.  Points within <code>geom</code> have a negative distance, and points outside of <code>geom</code> have a positive distance.</p><p>If <code>geom</code> is a MultiPolygon, then this function returns the maximum distance  to any of the polygons in <code>geom</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/signed_distance.jl#L91-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.simplify-Tuple{Any}" href="#GeometryOps.simplify-Tuple{Any}"><code>GeometryOps.simplify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify(obj; kw...)
simplify(::SimplifyAlg, obj)</code></pre><p>Simplify a geometry, feature, feature collection,  or nested vectors or a table of these.</p><p><a href="#GeometryOps.RadialDistance"><code>RadialDistance</code></a>, <a href="#GeometryOps.DouglasPeucker"><code>DouglasPeucker</code></a>, or  <a href="#GeometryOps.VisvalingamWhyatt"><code>VisvalingamWhyatt</code></a> algorithms are available,  listed in order of increasing quality but decreaseing performance.</p><p><code>PoinTrait</code> and <code>MultiPointTrait</code> are returned unchanged.</p><p>The default behaviour is <code>simplify(DouglasPeucker(; kw...), obj)</code>. Pass in other <a href="#GeometryOps.SimplifyAlg"><code>SimplifyAlg</code></a> to use other algorithms.</p><p><strong>Example</strong></p><p>Simplify a polygon to have six points:</p><pre><code class="language-julia hljs">import GeoInterface as GI
import GeometryOps as GO

poly = GI.Polygon([[
    [-70.603637, -33.399918],
    [-70.614624, -33.395332],
    [-70.639343, -33.392466],
    [-70.659942, -33.394759],
    [-70.683975, -33.404504],
    [-70.697021, -33.419406],
    [-70.701141, -33.434306],
    [-70.700454, -33.446339],
    [-70.694274, -33.458369],
    [-70.682601, -33.465816],
    [-70.668869, -33.472117],
    [-70.646209, -33.473835],
    [-70.624923, -33.472117],
    [-70.609817, -33.468107],
    [-70.595397, -33.458369],
    [-70.587158, -33.442901],
    [-70.587158, -33.426283],
    [-70.590591, -33.414248],
    [-70.594711, -33.406224],
    [-70.603637, -33.399918]]])

simple = GO.simplify(poly; number=6)
GI.npoint(simple)

# output
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/transformations/simplify.jl#L49-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1&lt;:Real, T2&lt;:Real}" href="#GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps.t_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)</code></pre><p>Returns the &quot;T-value&quot; as described in Hormann&#39;s presentation <sup class="footnote-reference"><a id="citeref-HormannPresentation" href="#footnote-HormannPresentation">[HormannPresentation]</a></sup> on how to calculate the mean-value coordinate.  </p><p>Here, <code>sᵢ</code> is the vector from vertex <code>vᵢ</code> to the point, and <code>rᵢ</code> is the norm (length) of <code>sᵢ</code>. <code>s</code> must be <code>Point</code> and <code>r</code> must be real numbers.</p><p class="math-container">\[tᵢ = \frac{\mathrm{det}\left(sᵢ, sᵢ₊₁\right)}{rᵢ * rᵢ₊₁ + sᵢ ⋅ sᵢ₊₁}\]</p><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/barycentric.jl#L246-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.to_edges-Tuple{Any}" href="#GeometryOps.to_edges-Tuple{Any}"><code>GeometryOps.to_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_edges()</code></pre><p>Convert any geometry or collection of geometries into a flat  vector of <code>Tuple{Tuple{Float64,Float64},Tuple{Float64,Float64}}</code> edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/utils.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.tuples-Tuple{Any}" href="#GeometryOps.tuples-Tuple{Any}"><code>GeometryOps.tuples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tuples(obj)</code></pre><p>Convert all points on obj to <code>Tuple</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/transformations/tuples.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.unwrap" href="#GeometryOps.unwrap"><code>GeometryOps.unwrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unwrap(target::Type{&lt;:AbstractTrait}, obj)
unwrap(f, target::Type{&lt;:AbstractTrait}, obj)</code></pre><p>Unwrap the geometry to vectors, down to the target trait.</p><p>If <code>f</code> is passed in it will be applied to the target geometries as they are found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/primitives.jl#L97-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT&lt;:Real" href="#GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT&lt;:Real"><code>GeometryOps.weighted_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weighted_mean(weight::Real, x1, x2)</code></pre><p>Returns the weighted mean of <code>x1</code> and <code>x2</code>, where <code>weight</code> is the weight of <code>x1</code>.</p><p>Specifically, calculates <code>x1 * weight + x2 * (1 - weight)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The idea for this method is that you can override this for custom types, like Color types, in extension modules.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/a2153c8f389d4163b869ec9da802198996827bc3/src/methods/barycentric.jl#L203-L212">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-HormannPresentation"><a class="tag is-link" href="#citeref-HormannPresentation">HormannPresentation</a>K. Hormann and N. Sukumar. Generalized Barycentric Coordinates in Computer Graphics and Computational Mechanics. Taylor &amp; Fancis, CRC Press, 2017.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="source/GeometryOps/">GeometryOps.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 22 December 2023 14:51">Friday 22 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
