<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · GeometryOps.jl</title><meta name="title" content="API Reference · GeometryOps.jl"/><meta property="og:title" content="API Reference · GeometryOps.jl"/><meta property="twitter:title" content="API Reference · GeometryOps.jl"/><meta name="description" content="Documentation for GeometryOps.jl."/><meta property="og:description" content="Documentation for GeometryOps.jl."/><meta property="twitter:description" content="Documentation for GeometryOps.jl."/><meta property="og:url" content="https://asinghvi17.github.io/GeometryOps.jl/api/"/><meta property="twitter:url" content="https://asinghvi17.github.io/GeometryOps.jl/api/"/><link rel="canonical" href="https://asinghvi17.github.io/GeometryOps.jl/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="GeometryOps.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">GeometryOps.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#apply-and-associated-functions"><span><code>apply</code> and associated functions</span></a></li><li><a class="tocitem" href="#General-geometry-methods"><span>General geometry methods</span></a></li><li><a class="tocitem" href="#Barycentric-coordinates"><span>Barycentric coordinates</span></a></li><li><a class="tocitem" href="#Other-methods"><span>Other methods</span></a></li></ul></li><li><span class="tocitem">Source code</span><ul><li><a class="tocitem" href="../source/GeometryOps/">GeometryOps.jl</a></li><li><a class="tocitem" href="../source/primitives/">Primitive functions</a></li><li><a class="tocitem" href="../source/utils/">Utility functions</a></li><li><a class="tocitem" href="../source/methods/angles/">Angles</a></li><li><a class="tocitem" href="../source/methods/area/">Area and signed area</a></li><li><a class="tocitem" href="../source/methods/barycentric/">Barycentric coordinates</a></li><li><a class="tocitem" href="../source/methods/bools/">Boolean conditions</a></li><li><a class="tocitem" href="../source/methods/centroid/">Centroid</a></li><li><a class="tocitem" href="../source/methods/distance/">Distance and signed distance</a></li><li><a class="tocitem" href="../source/methods/equals/">Equals</a></li><li><a class="tocitem" href="../source/methods/polygonize/">Polygonizing raster data</a></li><li><a class="tocitem" href="../source/methods/clipping/clipping_processor/">Polygon clipping helpers</a></li><li><a class="tocitem" href="../source/methods/clipping/difference/">Difference Polygon Clipping</a></li><li><a class="tocitem" href="../source/methods/clipping/intersection/">Intersection</a></li><li><a class="tocitem" href="../source/methods/clipping/union/">Union Polygon Clipping</a></li><li><a class="tocitem" href="../source/methods/geom_relations/contains/">Contains</a></li><li><a class="tocitem" href="../source/methods/geom_relations/coveredby/">CoveredBy</a></li><li><a class="tocitem" href="../source/methods/geom_relations/covers/">Covers</a></li><li><a class="tocitem" href="../source/methods/geom_relations/crosses/">Crossing checks</a></li><li><a class="tocitem" href="../source/methods/geom_relations/disjoint/">Disjoint</a></li><li><a class="tocitem" href="../source/methods/geom_relations/geom_geom_processors/">Line-curve interaction</a></li><li><a class="tocitem" href="../source/methods/geom_relations/intersects/">Intersection checks</a></li><li><a class="tocitem" href="../source/methods/geom_relations/overlaps/">Overlaps</a></li><li><a class="tocitem" href="../source/methods/geom_relations/touches/">Touches</a></li><li><a class="tocitem" href="../source/methods/geom_relations/within/">Within</a></li><li><a class="tocitem" href="../source/transformations/extent/">Extent embedding</a></li><li><a class="tocitem" href="../source/transformations/flip/">Coordinate flipping</a></li><li><a class="tocitem" href="../source/transformations/reproject/">Geometry reprojection</a></li><li><a class="tocitem" href="../source/transformations/simplify/">Geometry simplification</a></li><li><a class="tocitem" href="../source/transformations/transform/">Pointwise transformation</a></li><li><a class="tocitem" href="../source/transformations/tuples/">Tuple conversion</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/asinghvi17/GeometryOps.jl/blob/main/docs/src/api.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Full-GeometryOps-API-documentation"><a class="docs-heading-anchor" href="#Full-GeometryOps-API-documentation">Full GeometryOps API documentation</a><a id="Full-GeometryOps-API-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Full-GeometryOps-API-documentation" title="Permalink"></a></h1><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This page is still very much WIP!</p></div></div><p>Documentation for <a href="https://github.com/asinghvi17/GeometryOps.jl">GeometryOps</a>&#39;s full API (only for reference!).</p><ul><li><a href="#GeometryOps.AbstractBarycentricCoordinateMethod"><code>GeometryOps.AbstractBarycentricCoordinateMethod</code></a></li><li><a href="#GeometryOps.DouglasPeucker"><code>GeometryOps.DouglasPeucker</code></a></li><li><a href="#GeometryOps.LineOrientation"><code>GeometryOps.LineOrientation</code></a></li><li><a href="#GeometryOps.MeanValue"><code>GeometryOps.MeanValue</code></a></li><li><a href="#GeometryOps.PointOrientation"><code>GeometryOps.PointOrientation</code></a></li><li><a href="#GeometryOps.RadialDistance"><code>GeometryOps.RadialDistance</code></a></li><li><a href="#GeometryOps.SimplifyAlg"><code>GeometryOps.SimplifyAlg</code></a></li><li><a href="#GeometryOps.VisvalingamWhyatt"><code>GeometryOps.VisvalingamWhyatt</code></a></li><li><a href="#GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps._det</code></a></li><li><a href="#GeometryOps._equals_curves-NTuple{4, Any}"><code>GeometryOps._equals_curves</code></a></li><li><a href="#GeometryOps.angles-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat"><code>GeometryOps.angles</code></a></li><li><a href="#GeometryOps.angles"><code>GeometryOps.angles</code></a></li><li><a href="#GeometryOps.apply"><code>GeometryOps.apply</code></a></li><li><a href="#GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target"><code>GeometryOps.apply</code></a></li><li><a href="#GeometryOps.applyreduce"><code>GeometryOps.applyreduce</code></a></li><li><a href="#GeometryOps.area-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat"><code>GeometryOps.area</code></a></li><li><a href="#GeometryOps.area"><code>GeometryOps.area</code></a></li><li><a href="#GeometryOps.centroid-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T"><code>GeometryOps.centroid</code></a></li><li><a href="#GeometryOps.centroid"><code>GeometryOps.centroid</code></a></li><li><a href="#GeometryOps.centroid_and_area-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T"><code>GeometryOps.centroid_and_area</code></a></li><li><a href="#GeometryOps.centroid_and_length-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T"><code>GeometryOps.centroid_and_length</code></a></li><li><a href="#GeometryOps.contains-Tuple{Any, Any}"><code>GeometryOps.contains</code></a></li><li><a href="#GeometryOps.contains"><code>GeometryOps.contains</code></a></li><li><a href="#GeometryOps.coveredby-Tuple{Any, Any}"><code>GeometryOps.coveredby</code></a></li><li><a href="#GeometryOps.coveredby"><code>GeometryOps.coveredby</code></a></li><li><a href="#GeometryOps.covers"><code>GeometryOps.covers</code></a></li><li><a href="#GeometryOps.covers-Tuple{Any, Any}"><code>GeometryOps.covers</code></a></li><li><a href="#GeometryOps.crosses"><code>GeometryOps.crosses</code></a></li><li><a href="#GeometryOps.crosses-Tuple{Any, Any}"><code>GeometryOps.crosses</code></a></li><li><a href="#GeometryOps.difference-Union{Tuple{Target}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where {T&lt;:AbstractFloat, Target&lt;:GeoInterface.AbstractTrait}"><code>GeometryOps.difference</code></a></li><li><a href="#GeometryOps.disjoint-Tuple{Any, Any}"><code>GeometryOps.disjoint</code></a></li><li><a href="#GeometryOps.disjoint"><code>GeometryOps.disjoint</code></a></li><li><a href="#GeometryOps.distance"><code>GeometryOps.distance</code></a></li><li><a href="#GeometryOps.distance-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T&lt;:AbstractFloat"><code>GeometryOps.distance</code></a></li><li><a href="#GeometryOps.embed_extent"><code>GeometryOps.embed_extent</code></a></li><li><a href="#GeometryOps.embed_extent-Tuple{Any}"><code>GeometryOps.embed_extent</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.PointTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{Any, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, GeoInterface.LinearRingTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, GeoInterface.LinearRingTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.PointTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-NTuple{4, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Union{Tuple{T}, Tuple{T, Any, T, Any}} where T"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}"><code>GeometryOps.equals</code></a></li><li><a href="#GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target&lt;:GeoInterface.AbstractTrait"><code>GeometryOps.flatten</code></a></li><li><a href="#GeometryOps.flip-Tuple{Any}"><code>GeometryOps.flip</code></a></li><li><a href="#GeometryOps.get_contours-Tuple{AbstractMatrix}"><code>GeometryOps.get_contours</code></a></li><li><a href="#GeometryOps.intersection-Union{Tuple{Target}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where {T&lt;:AbstractFloat, Target&lt;:GeoInterface.AbstractTrait}"><code>GeometryOps.intersection</code></a></li><li><a href="#GeometryOps.intersection_points-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T&lt;:AbstractFloat"><code>GeometryOps.intersection_points</code></a></li><li><a href="#GeometryOps.intersects-Tuple{Any, Any}"><code>GeometryOps.intersects</code></a></li><li><a href="#GeometryOps.intersects"><code>GeometryOps.intersects</code></a></li><li><a href="#GeometryOps.isclockwise-Tuple{Any}"><code>GeometryOps.isclockwise</code></a></li><li><a href="#GeometryOps.isconcave-Tuple{Any}"><code>GeometryOps.isconcave</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{Any, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.overlaps-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any}"><code>GeometryOps.overlaps</code></a></li><li><a href="#GeometryOps.polygon_to_line-Tuple{Any}"><code>GeometryOps.polygon_to_line</code></a></li><li><a href="#GeometryOps.polygonize-Tuple{AbstractMatrix}"><code>GeometryOps.polygonize</code></a></li><li><a href="#GeometryOps.rebuild-Tuple{Any, Any}"><code>GeometryOps.rebuild</code></a></li><li><a href="#GeometryOps.reconstruct-Tuple{Any, Any}"><code>GeometryOps.reconstruct</code></a></li><li><a href="#GeometryOps.reproject"><code>GeometryOps.reproject</code></a></li><li><a href="#GeometryOps.reproject-Tuple{Any}"><code>GeometryOps.reproject</code></a></li><li><a href="#GeometryOps.signed_area"><code>GeometryOps.signed_area</code></a></li><li><a href="#GeometryOps.signed_area-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat"><code>GeometryOps.signed_area</code></a></li><li><a href="#GeometryOps.signed_distance"><code>GeometryOps.signed_distance</code></a></li><li><a href="#GeometryOps.signed_distance-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T&lt;:AbstractFloat"><code>GeometryOps.signed_distance</code></a></li><li><a href="#GeometryOps.simplify-Tuple{GeometryOps.SimplifyAlg, Any}"><code>GeometryOps.simplify</code></a></li><li><a href="#GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps.t_value</code></a></li><li><a href="#GeometryOps.to_edges-Tuple{Any}"><code>GeometryOps.to_edges</code></a></li><li><a href="#GeometryOps.touches-Tuple{Any, Any}"><code>GeometryOps.touches</code></a></li><li><a href="#GeometryOps.touches"><code>GeometryOps.touches</code></a></li><li><a href="#GeometryOps.transform-Tuple{Any, Any}"><code>GeometryOps.transform</code></a></li><li><a href="#GeometryOps.transform"><code>GeometryOps.transform</code></a></li><li><a href="#GeometryOps.tuples-Tuple{Any}"><code>GeometryOps.tuples</code></a></li><li><a href="#GeometryOps.union-Union{Tuple{Target}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where {T&lt;:AbstractFloat, Target&lt;:GeoInterface.AbstractTrait}"><code>GeometryOps.union</code></a></li><li><a href="#GeometryOps.unwrap"><code>GeometryOps.unwrap</code></a></li><li><a href="#GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT&lt;:Real"><code>GeometryOps.weighted_mean</code></a></li><li><a href="#GeometryOps.within-Tuple{Any, Any}"><code>GeometryOps.within</code></a></li><li><a href="#GeometryOps.within"><code>GeometryOps.within</code></a></li></ul><h2 id="apply-and-associated-functions"><a class="docs-heading-anchor" href="#apply-and-associated-functions"><code>apply</code> and associated functions</a><a id="apply-and-associated-functions-1"></a><a class="docs-heading-anchor-permalink" href="#apply-and-associated-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.apply" href="#GeometryOps.apply"><code>GeometryOps.apply</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply(f, target::Type{&lt;:AbstractTrait}, obj; kw...)</code></pre><p>Reconstruct a geometry, feature, feature collection, or nested vectors of either using the function <code>f</code> on the <code>target</code> trait.</p><p><code>f(target_geom) =&gt; x</code> where <code>x</code> also has the <code>target</code> trait, or a trait that can be substituted. For example, swapping <code>PolgonTrait</code> to <code>MultiPointTrait</code> will fail if the outer object has <code>MultiPolygonTrait</code>, but should work if it has <code>FeatureTrait</code>.</p><p>Objects &quot;shallower&quot; than the target trait are always completely rebuilt, like a <code>Vector</code> of <code>FeatureCollectionTrait</code> of <code>FeatureTrait</code> when the target has <code>PolygonTrait</code> and is held in the features. But &quot;deeper&quot; objects may remain unchanged - such as points and linear rings if the target is the same <code>PolygonTrait</code>.</p><p>The result is a functionally similar geometry with values depending on <code>f</code></p><ul><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li><li><code>calc_extent</code>: <code>true</code> or <code>false</code>. Whether to calculate the extent. Defaults to <code>false</code>.</li></ul><p><strong>Example</strong></p><p>Flipped point the order in any feature or geometry, or iterables of either:</p><p>```julia import GeoInterface as GI import GeometryOps as GO geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]),                    GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])])</p><p>flipped_geom = GO.apply(GI.PointTrait, geom) do p     (GI.y(p), GI.x(p)) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/primitives.jl#L62-L94">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>apply_reduce</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.reproject" href="#GeometryOps.reproject"><code>GeometryOps.reproject</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reproject(geometry; source_crs, target_crs, transform, always_xy, time)
reproject(geometry, source_crs, target_crs; always_xy, time)
reproject(geometry, transform; always_xy, time)</code></pre><p>Reproject any GeoInterface.jl compatible <code>geometry</code> from <code>source_crs</code> to <code>target_crs</code>.</p><p>The returned object will be constructed from <code>GeoInterface.WrapperGeometry</code> geometries, wrapping views of a <code>Vector{Proj.Point{D}}</code>, where <code>D</code> is the dimension.</p><p><strong>Arguments</strong></p><ul><li><code>geometry</code>: Any GeoInterface.jl compatible geometries.</li><li><code>source_crs</code>: the source coordinate referece system, as a GeoFormatTypes.jl object or a string.</li><li><code>target_crs</code>: the target coordinate referece system, as a GeoFormatTypes.jl object or a string.</li></ul><p>If these a passed as keywords, <code>transform</code> will take priority. Without it <code>target_crs</code> is always needed, and <code>source_crs</code> is needed if it is not retreivable from the geometry with <code>GeoInterface.crs(geometry)</code>.</p><p><strong>Keywords</strong></p><ul><li><code>always_xy</code>: force x, y coordinate order, <code>true</code> by default.   <code>false</code> will expect and return points in the crs coordinate order.</li><li><code>time</code>: the time for the coordinates. <code>Inf</code> by default.</li><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li><li><code>calc_extent</code>: <code>true</code> or <code>false</code>. Whether to calculate the extent. Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/reproject.jl#L11-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.transform" href="#GeometryOps.transform"><code>GeometryOps.transform</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform(f, obj)</code></pre><p>Apply a function <code>f</code> to all the points in <code>obj</code>.</p><p>Points will be passed to <code>f</code> as an <code>SVector</code> to allow using CoordinateTransformations.jl and Rotations.jl  without hassle.</p><p><code>SVector</code> is also a valid GeoInterface.jl point, so will work in all GeoInterface.jl methods.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; import GeoInterface as GI

julia&gt; import GeometryOps as GO

julia&gt; geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]), GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])]);

julia&gt; f = CoordinateTransformations.Translation(3.5, 1.5)
Translation(3.5, 1.5)

julia&gt; GO.transform(f, geom)
GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}}, Nothing, Nothing}(GeoInterface.Wrappers.Linea
rRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}[GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}(StaticArraysCo
re.SVector{2, Float64}[[4.5, 3.5], [6.5, 5.5], [8.5, 7.5], [4.5, 3.5]], nothing, nothing), GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}(StaticA
rraysCore.SVector{2, Float64}[[6.5, 5.5], [8.5, 7.5], [9.5, 8.5], [6.5, 5.5]], nothing, nothing)], nothing, nothing)</code></pre><p>With Rotations.jl you need to actuall multiply the Rotation by the <code>SVector</code> point, which is easy using an anonymous function.</p><pre><code class="language-julia hljs">julia&gt; using Rotations

julia&gt; GO.transform(p -&gt; one(RotMatrix{2}) * p, geom)
GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}}, Nothing, Nothing}(GeoInterface.Wrappers.LinearR
ing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}[GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}(StaticArraysCore.SVe
ctor{2, Int64}[[2, 1], [4, 3], [6, 5], [2, 1]], nothing, nothing), GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}(StaticArraysCore.SVector{2, Int64
}[[4, 3], [6, 5], [7, 6], [4, 3]], nothing, nothing)], nothing, nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/transform.jl#L3-L46">source</a></section></article><h2 id="General-geometry-methods"><a class="docs-heading-anchor" href="#General-geometry-methods">General geometry methods</a><a id="General-geometry-methods-1"></a><a class="docs-heading-anchor-permalink" href="#General-geometry-methods" title="Permalink"></a></h2><h3 id="OGC-methods"><a class="docs-heading-anchor" href="#OGC-methods">OGC methods</a><a id="OGC-methods-1"></a><a class="docs-heading-anchor-permalink" href="#OGC-methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.contains" href="#GeometryOps.contains"><code>GeometryOps.contains</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contains(g1::AbstractGeometry, g2::AbstractGeometry)::Bool</code></pre><p>Return true if the second geometry is completely contained by the first geometry. The interiors of both geometries must intersect and the interior and boundary of the secondary (g2) must not intersect the exterior of the first (g1).</p><p><code>contains</code> returns the exact opposite result of <code>within</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
line = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
point = GI.Point((1, 2))

GO.contains(line, point)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/contains.jl#L43-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.coveredby" href="#GeometryOps.coveredby"><code>GeometryOps.coveredby</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coveredby(g1, g2)::Bool</code></pre><p>Return <code>true</code> if the first geometry is completely covered by the second geometry. The interior and boundary of the primary geometry (g1) must not intersect the exterior of the secondary geometry (g2).</p><p>Furthermore, <code>coveredby</code> returns the exact opposite result of <code>covers</code>. They are equivalent with the order of the arguments swapped.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
p1 = GI.Point(0.0, 0.0)
p2 = GI.Point(1.0, 1.0)
l1 = GI.Line([p1, p2])

GO.coveredby(p1, l1)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/coveredby.jl#L57-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.covers" href="#GeometryOps.covers"><code>GeometryOps.covers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">covers(g1::AbstractGeometry, g2::AbstractGeometry)::Bool</code></pre><p>Return true if the first geometry is completely covers the second geometry,  The exterior and boundary of the second geometry must not be outside of the interior and boundary of the first geometry. However, the interiors need not intersect.</p><p><code>covers</code> returns the exact opposite result of <code>coveredby</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
l1 = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
l2 = GI.LineString([(1, 1), (1, 2)])

GO.covers(l1, l2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/covers.jl#L42-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.crosses" href="#GeometryOps.crosses"><code>GeometryOps.crosses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> crosses(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the intersection results in a geometry whose dimension is one less than the maximum dimension of the two source geometries and the intersection set is interior to both source geometries.</p><p>TODO: broken</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO
# TODO: Add working example</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/crosses.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.disjoint" href="#GeometryOps.disjoint"><code>GeometryOps.disjoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">disjoint(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the first geometry is disjoint from the second geometry.</p><p>Return <code>true</code> if the first geometry is disjoint from the second geometry. The interiors and boundaries of both geometries must not intersect.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

line = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
point = (2, 2)
GO.disjoint(point, line)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/disjoint.jl#L54-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.intersects" href="#GeometryOps.intersects"><code>GeometryOps.intersects</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">intersects(geom1, geom2)::Bool</code></pre><p>Return true if the interiors or boundaries of the two geometries interact.</p><p><code>intersects</code> returns the exact opposite result of <code>disjoint</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

line1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])
line2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])
GO.intersects(line1, line2)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/intersects.jl#L38-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.overlaps" href="#GeometryOps.overlaps"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">overlaps(geom1, geom2)::Bool</code></pre><p>Compare two Geometries of the same dimension and return true if their intersection set results in a geometry different from both but of the same dimension. This means one geometry cannot be within or contain the other and they cannot be equal</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
poly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])
poly2 = GI.Polygon([[(1,1), (1,6), (6,6), (6,1), (1,1)]])

GO.overlaps(poly1, poly2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L53-L71">source</a></section><section><div><pre><code class="language-julia hljs">overlaps(::GI.AbstractTrait, geom1, ::GI.AbstractTrait, geom2)::Bool</code></pre><p>For any non-specified pair, all have non-matching dimensions, return false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L79-L83">source</a></section><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.MultiPointTrait, points1,
    ::GI.MultiPointTrait, points2,
)::Bool</code></pre><p>If the multipoints overlap, meaning some, but not all, of the points within the multipoints are shared, return true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L86-L94">source</a></section><section><div><pre><code class="language-julia hljs">overlaps(::GI.LineTrait, line1, ::GI.LineTrait, line)::Bool</code></pre><p>If the lines overlap, meaning that they are colinear but each have one endpoint outside of the other line, return true. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L116-L121">source</a></section><section><div><pre><code class="language-julia hljs">overlaps(
    ::Union{GI.LineStringTrait, GI.LinearRing}, line1,
    ::Union{GI.LineStringTrait, GI.LinearRing}, line2,
)::Bool</code></pre><p>If the curves overlap, meaning that at least one edge of each curve overlaps, return true. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L125-L133">source</a></section><section><div><pre><code class="language-julia hljs">overlaps(
    trait_a::GI.PolygonTrait, poly_a,
    trait_b::GI.PolygonTrait, poly_b,
)::Bool</code></pre><p>If the two polygons intersect with one another, but are not equal, return true. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L147-L155">source</a></section><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.PolygonTrait, poly1,
    ::GI.MultiPolygonTrait, polys2,
)::Bool</code></pre><p>Return true if polygon overlaps with at least one of the polygons within the multipolygon. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L165-L173">source</a></section><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.MultiPolygonTrait, polys1,
    ::GI.PolygonTrait, poly2,
)::Bool</code></pre><p>Return true if polygon overlaps with at least one of the polygons within the multipolygon. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L184-L192">source</a></section><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.MultiPolygonTrait, polys1,
    ::GI.MultiPolygonTrait, polys2,
)::Bool</code></pre><p>Return true if at least one pair of polygons from multipolygons overlap. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L196-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.touches" href="#GeometryOps.touches"><code>GeometryOps.touches</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">touches(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the first geometry touches the second geometry. In other words, the two interiors cannot interact, but one of the geometries must have a boundary point that interacts with either the other geometies interior or boundary.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

l1 = GI.Line([(0.0, 0.0), (1.0, 0.0)])
l2 = GI.Line([(1.0, 1.0), (1.0, -1.0)])

GO.touches(l1, l2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/touches.jl#L58-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.within" href="#GeometryOps.within"><code>GeometryOps.within</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">within(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the first geometry is completely within the second geometry. The interiors of both geometries must intersect and the interior and boundary of the primary geometry (geom1) must not intersect the exterior of the secondary geometry (geom2).</p><p>Furthermore, <code>within</code> returns the exact opposite result of <code>contains</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

line = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
point = (1, 2)
GO.within(point, line)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/within.jl#L60-L81">source</a></section></article><h3 id="Other-general-methods"><a class="docs-heading-anchor" href="#Other-general-methods">Other general methods</a><a id="Other-general-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Other-general-methods" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals" href="#GeometryOps.equals"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">equals(geom1, geom2)::Bool</code></pre><p>Compare two Geometries return true if they are the same geometry.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
poly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])
poly2 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])

GO.equals(poly1, poly2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L52-L67">source</a></section><section><div><pre><code class="language-julia hljs">equals(::T, geom_a, ::T, geom_b)::Bool</code></pre><p>Two geometries of the same type, which don&#39;t have a equals function to dispatch off of should throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L73-L78">source</a></section><section><div><pre><code class="language-julia hljs">equals(trait_a, geom_a, trait_b, geom_b)</code></pre><p>Two geometries which are not of the same type cannot be equal so they always return false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L81-L86">source</a></section><section><div><pre><code class="language-julia hljs">equals(::GI.PointTrait, p1, ::GI.PointTrait, p2)::Bool</code></pre><p>Two points are the same if they have the same x and y (and z if 3D) coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L89-L93">source</a></section><section><div><pre><code class="language-julia hljs">equals(::GI.PointTrait, p1, ::GI.MultiPointTrait, mp2)::Bool</code></pre><p>A point and a multipoint are equal if the multipoint is composed of a single point that is equivalent to the given point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L104-L109">source</a></section><section><div><pre><code class="language-julia hljs">equals(::GI.MultiPointTrait, mp1, ::GI.PointTrait, p2)::Bool</code></pre><p>A point and a multipoint are equal if the multipoint is composed of a single point that is equivalent to the given point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L115-L120">source</a></section><section><div><pre><code class="language-julia hljs">equals(::GI.MultiPointTrait, mp1, ::GI.MultiPointTrait, mp2)::Bool</code></pre><p>Two multipoints are equal if they share the same set of points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L124-L128">source</a></section><section><div><pre><code class="language-julia hljs">equals(
    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,
    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,
)::Bool</code></pre><p>Two lines/linestrings are equal if they share the same set of points going along the curve. Note that lines/linestrings aren&#39;t closed by defintion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L206-L214">source</a></section><section><div><pre><code class="language-julia hljs">equals(
    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,
    ::GI.LinearRingTrait, l2,
)::Bool</code></pre><p>A line/linestring and a linear ring are equal if they share the same set of points going along the curve. Note that lines aren&#39;t closed by defintion, but rings are, so the line must have a repeated last point to be equal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L220-L229">source</a></section><section><div><pre><code class="language-julia hljs">equals(
    ::GI.LinearRingTrait, l1,
    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,
)::Bool</code></pre><p>A linear ring and a line/linestring are equal if they share the same set of points going along the curve. Note that lines aren&#39;t closed by defintion, but rings are, so the line must have a repeated last point to be equal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L235-L244">source</a></section><section><div><pre><code class="language-julia hljs">equals(
    ::GI.LinearRingTrait, l1,
    ::GI.LinearRingTrait, l2,
)::Bool</code></pre><p>Two linear rings are equal if they share the same set of points going along the curve. Note that rings are closed by definition, so they can have, but don&#39;t need, a repeated last point to be equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L250-L259">source</a></section><section><div><pre><code class="language-julia hljs">equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool</code></pre><p>Two polygons are equal if they share the same exterior edge and holes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L265-L269">source</a></section><section><div><pre><code class="language-julia hljs">equals(::GI.PolygonTrait, geom_a, ::GI.MultiPolygonTrait, geom_b)::Bool</code></pre><p>A polygon and a multipolygon are equal if the multipolygon is composed of a single polygon that is equivalent to the given polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L295-L300">source</a></section><section><div><pre><code class="language-julia hljs">equals(::GI.MultiPolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool</code></pre><p>A polygon and a multipolygon are equal if the multipolygon is composed of a single polygon that is equivalent to the given polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L306-L311">source</a></section><section><div><pre><code class="language-julia hljs">equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool</code></pre><p>Two multipolygons are equal if they share the same set of polygons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.centroid" href="#GeometryOps.centroid"><code>GeometryOps.centroid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">centroid(geom, [T=Float64])::Tuple{T, T}</code></pre><p>Returns the centroid of a given line segment, linear ring, polygon, or mutlipolygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/centroid.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.distance" href="#GeometryOps.distance"><code>GeometryOps.distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">distance(point, geom, ::Type{T} = Float64)::T</code></pre><p>Calculates the  ditance from the geometry <code>g1</code> to the <code>point</code>. The distance will always be positive or zero.</p><p>The method will differ based on the type of the geometry provided:     - The distance from a point to a point is just the Euclidean distance     between the points.     - The distance from a point to a line is the minimum distance from the point     to the closest point on the given line.     - The distance from a point to a linestring is the minimum distance from the     point to the closest segment of the linestring.     - The distance from a point to a linear ring is the minimum distance from     the point to the closest segment of the linear ring.     - The distance from a point to a polygon is zero if the point is within the     polygon and otherwise is the minimum distance from the point to an edge of     the polygon. This includes edges created by holes.     - The distance from a point to a multigeometry or a geometry collection is     the minimum distance between the point and any of the sub-geometries.</p><p>Result will be of type T, where T is an optional argument with a default value of Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/distance.jl#L68-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.signed_distance" href="#GeometryOps.signed_distance"><code>GeometryOps.signed_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">signed_distance(point, geom, ::Type{T} = Float64)::T</code></pre><p>Calculates the signed distance from the geometry <code>geom</code> to the given point. Points within <code>geom</code> have a negative signed distance, and points outside of <code>geom</code> have a positive signed distance.     - The signed distance from a point to a point, line, linestring, or linear     ring is equal to the distance between the two.     - The signed distance from a point to a polygon is negative if the point is     within the polygon and is positive otherwise. The value of the distance is     the minimum distance from the point to an edge of the polygon. This includes     edges created by holes.     - The signed distance from a point to a multigeometry or a geometry     collection is the minimum signed distance between the point and any of the     sub-geometries.</p><p>Result will be of type T, where T is an optional argument with a default value of Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/distance.jl#L134-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.area" href="#GeometryOps.area"><code>GeometryOps.area</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">area(geom, ::Type{T} = Float64)::T</code></pre><p>Returns the area of a geometry or collection of geometries.  This is computed slightly differently for different geometries:</p><pre><code class="nohighlight hljs">- The area of a point/multipoint is always zero.
- The area of a curve/multicurve is always zero.
- The area of a polygon is the absolute value of the signed area.
- The area multi-polygon is the sum of the areas of all of the sub-polygons.
- The area of a geometry collection, feature collection of array/iterable 
    is the sum of the areas of all of the sub-geometries.</code></pre><p>Result will be of type T, where T is an optional argument with a default value of Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/area.jl#L54-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.signed_area" href="#GeometryOps.signed_area"><code>GeometryOps.signed_area</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">signed_area(geom, ::Type{T} = Float64)::T</code></pre><p>Returns the signed area of a single geometry, based on winding order.  This is computed slighly differently for different geometries:</p><pre><code class="nohighlight hljs">- The signed area of a point is always zero.
- The signed area of a curve is always zero.
- The signed area of a polygon is computed with the shoelace formula and is
positive if the polygon coordinates wind clockwise and negative if
counterclockwise.
- You cannot compute the signed area of a multipolygon as it doesn&#39;t have a
meaning as each sub-polygon could have a different winding order.</code></pre><p>Result will be of type T, where T is an optional argument with a default value of Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/area.jl#L77-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.angles" href="#GeometryOps.angles"><code>GeometryOps.angles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">angles(geom, ::Type{T} = Float64)</code></pre><p>Returns the angles of a geometry or collection of geometries.  This is computed differently for different geometries:</p><pre><code class="nohighlight hljs">- The angles of a point is an empty vector.
- The angles of a single line segment is an empty vector.
- The angles of a linestring or linearring is a vector of angles formed by the curve.
- The angles of a polygin is a vector of vectors of angles formed by each ring.
- The angles of a multi-geometry collection is a vector of the angles of each of the
    sub-geometries as defined above.</code></pre><p>Result will be a Vector, or nested set of vectors, of type T where an optional argument with a default value of Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/angles.jl#L33-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.embed_extent" href="#GeometryOps.embed_extent"><code>GeometryOps.embed_extent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">embed_extent(obj)</code></pre><p>Recursively wrap the object with a GeoInterface.jl geometry, calculating and adding an <code>Extents.Extent</code> to all objects.</p><p>This can improve performance when extents need to be checked multiple times, such when needing to check if many points are in geometries, and using their extents as a quick filter for obviously exterior points.</p><p><strong>Keywords</strong></p><ul><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/extent.jl#L3-L17">source</a></section></article><h2 id="Barycentric-coordinates"><a class="docs-heading-anchor" href="#Barycentric-coordinates">Barycentric coordinates</a><a id="Barycentric-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Barycentric-coordinates" title="Permalink"></a></h2><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>barycentric_coordinates</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>barycentric_coordinates!</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>barycentric_interpolate</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Other-methods"><a class="docs-heading-anchor" href="#Other-methods">Other methods</a><a id="Other-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Other-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.AbstractBarycentricCoordinateMethod" href="#GeometryOps.AbstractBarycentricCoordinateMethod"><code>GeometryOps.AbstractBarycentricCoordinateMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractBarycentricCoordinateMethod</code></pre><p>Abstract supertype for barycentric coordinate methods.   The subtypes may serve as dispatch types, or may cache  some information about the target polygon.  </p><p><strong>API</strong></p><p>The following methods must be implemented for all subtypes:</p><ul><li><code>barycentric_coordinates!(λs::Vector{&lt;: Real}, method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, point::Point{2, T2})</code></li><li><code>barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, values::Vector{V}, point::Point{2, T2})::V</code></li><li><code>barycentric_interpolate(method::AbstractBarycentricCoordinateMethod, exterior::Vector{&lt;: Point{2, T1}}, interiors::Vector{&lt;: Vector{&lt;: Point{2, T1}}} values::Vector{V}, point::Point{2, T2})::V</code></li></ul><p>The rest of the methods will be implemented in terms of these, and have efficient dispatches for broadcasting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/barycentric.jl#L116-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.DouglasPeucker" href="#GeometryOps.DouglasPeucker"><code>GeometryOps.DouglasPeucker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DouglasPeucker &lt;: SimplifyAlg

DouglasPeucker(; number, ratio, tol)</code></pre><p>Simplifies geometries by removing points below <code>tol</code> distance from the line between its neighboring points.</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum distance a point will be from the line   joining its neighboring points.</p></li></ul><p>Note: user input <code>tol</code> is squared to avoid uneccesary computation in algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/simplify.jl#L213-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.LineOrientation" href="#GeometryOps.LineOrientation"><code>GeometryOps.LineOrientation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Enum LineOrientation</code></pre><p>Enum for the orientation of a line with respect to a curve. A line can be <code>line_cross</code> (crossing over the curve), <code>line_hinge</code> (crossing the endpoint of the curve), <code>line_over</code> (colinear with the curve), or <code>line_out</code> (not interacting with the curve).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/geom_geom_processors.jl#L15-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.MeanValue" href="#GeometryOps.MeanValue"><code>GeometryOps.MeanValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MeanValue() &lt;: AbstractBarycentricCoordinateMethod</code></pre><p>This method calculates barycentric coordinates using the mean value method.</p><p><strong>References</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/barycentric.jl#L222-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.PointOrientation" href="#GeometryOps.PointOrientation"><code>GeometryOps.PointOrientation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Enum PointOrientation</code></pre><p>Enum for the orientation of a point with respect to a curve. A point can be <code>point_in</code> the curve, <code>point_on</code> the curve, or <code>point_out</code> of the curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/geom_geom_processors.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.RadialDistance" href="#GeometryOps.RadialDistance"><code>GeometryOps.RadialDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadialDistance &lt;: SimplifyAlg</code></pre><p>Simplifies geometries by removing points less than <code>tol</code> distance from the line between its neighboring points.</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum distance between points.</p></li></ul><p>Note: user input <code>tol</code> is squared to avoid uneccesary computation in algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/simplify.jl#L174-L184">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.SimplifyAlg" href="#GeometryOps.SimplifyAlg"><code>GeometryOps.SimplifyAlg</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type SimplifyAlg</code></pre><p>Abstract type for simplification algorithms.</p><p><strong>API</strong></p><p>For now, the algorithm must hold the <code>number</code>, <code>ratio</code> and <code>tol</code> properties.  </p><p>Simplification algorithm types can hook into the interface by implementing  the <code>_simplify(trait, alg, geom)</code> methods for whichever traits are necessary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/simplify.jl#L46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.VisvalingamWhyatt" href="#GeometryOps.VisvalingamWhyatt"><code>GeometryOps.VisvalingamWhyatt</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VisvalingamWhyatt &lt;: SimplifyAlg

VisvalingamWhyatt(; kw...)</code></pre><p>Simplifies geometries by removing points below <code>tol</code> distance from the line between its neighboring points.</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum area of a triangle made with a point and   its neighboring points.</p></li></ul><p>Note: user input <code>tol</code> is doubled to avoid uneccesary computation in algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/simplify.jl#L345-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1&lt;:Real, T2&lt;:Real}" href="#GeometryOps._det-Union{Tuple{T2}, Tuple{T1}, Tuple{Union{Tuple{T1, T1}, StaticArraysCore.StaticArray{Tuple{2}, T1, 1}}, Union{Tuple{T2, T2}, StaticArraysCore.StaticArray{Tuple{2}, T2, 1}}}} where {T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps._det</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_det(s1::Point2{T1}, s2::Point2{T2}) where {T1 &lt;: Real, T2 &lt;: Real}</code></pre><p>Returns the determinant of the matrix formed by <code>hcat</code>&#39;ing two points <code>s1</code> and <code>s2</code>.</p><p>Specifically, this is: </p><pre><code class="language-julia hljs">s1[1] * s2[2] - s1[2] * s2[1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/barycentric.jl#L236-L245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps._equals_curves-NTuple{4, Any}" href="#GeometryOps._equals_curves-NTuple{4, Any}"><code>GeometryOps._equals_curves</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_equals_curves(c1, c2, closed_type1, closed_type2)::Bool</code></pre><p>Two curves are equal if they share the same set of point, representing the same geometry. Both curves must must be composed of the same set of points, however, they do not have to wind in the same direction, or start on the same point to be equivalent. Inputs:     c1 first geometry     c2 second geometry     closed<em>type1::Bool true if c1 is closed by definition (polygon, linear ring)     closed</em>type2::Bool true if c2 is closed by definition (polygon, linear ring)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L144-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.angles-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat" href="#GeometryOps.angles-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat"><code>GeometryOps.angles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angles(geom, ::Type{T} = Float64)</code></pre><p>Returns the angles of a geometry or collection of geometries.  This is computed differently for different geometries:</p><pre><code class="nohighlight hljs">- The angles of a point is an empty vector.
- The angles of a single line segment is an empty vector.
- The angles of a linestring or linearring is a vector of angles formed by the curve.
- The angles of a polygin is a vector of vectors of angles formed by each ring.
- The angles of a multi-geometry collection is a vector of the angles of each of the
    sub-geometries as defined above.</code></pre><p>Result will be a Vector, or nested set of vectors, of type T where an optional argument with a default value of Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/angles.jl#L33-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target" href="#GeometryOps.apply-Union{Tuple{Target}, Tuple{Any, Type{Target}, Any}} where Target"><code>GeometryOps.apply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply(f, target::Type{&lt;:AbstractTrait}, obj; kw...)</code></pre><p>Reconstruct a geometry, feature, feature collection, or nested vectors of either using the function <code>f</code> on the <code>target</code> trait.</p><p><code>f(target_geom) =&gt; x</code> where <code>x</code> also has the <code>target</code> trait, or a trait that can be substituted. For example, swapping <code>PolgonTrait</code> to <code>MultiPointTrait</code> will fail if the outer object has <code>MultiPolygonTrait</code>, but should work if it has <code>FeatureTrait</code>.</p><p>Objects &quot;shallower&quot; than the target trait are always completely rebuilt, like a <code>Vector</code> of <code>FeatureCollectionTrait</code> of <code>FeatureTrait</code> when the target has <code>PolygonTrait</code> and is held in the features. But &quot;deeper&quot; objects may remain unchanged - such as points and linear rings if the target is the same <code>PolygonTrait</code>.</p><p>The result is a functionally similar geometry with values depending on <code>f</code></p><ul><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li><li><code>calc_extent</code>: <code>true</code> or <code>false</code>. Whether to calculate the extent. Defaults to <code>false</code>.</li></ul><p><strong>Example</strong></p><p>Flipped point the order in any feature or geometry, or iterables of either:</p><p>```julia import GeoInterface as GI import GeometryOps as GO geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]),                    GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])])</p><p>flipped_geom = GO.apply(GI.PointTrait, geom) do p     (GI.y(p), GI.x(p)) end</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/primitives.jl#L62-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.applyreduce" href="#GeometryOps.applyreduce"><code>GeometryOps.applyreduce</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">applyreduce(f, op, target::Type{&lt;:AbstractTrait}, obj; threaded)</code></pre><p>Apply function <code>f</code> to all objects with the <code>target</code> trait, and reduce the result with an <code>op</code> like <code>+</code>. </p><p>The order and grouping of application of <code>op</code> is not guaranteed.</p><p>If <code>threaded==true</code> threads will be used over arrays and iterables,  feature collections and nested geometries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/primitives.jl#L197-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.area-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat" href="#GeometryOps.area-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat"><code>GeometryOps.area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">area(geom, ::Type{T} = Float64)::T</code></pre><p>Returns the area of a geometry or collection of geometries.  This is computed slightly differently for different geometries:</p><pre><code class="nohighlight hljs">- The area of a point/multipoint is always zero.
- The area of a curve/multicurve is always zero.
- The area of a polygon is the absolute value of the signed area.
- The area multi-polygon is the sum of the areas of all of the sub-polygons.
- The area of a geometry collection, feature collection of array/iterable 
    is the sum of the areas of all of the sub-geometries.</code></pre><p>Result will be of type T, where T is an optional argument with a default value of Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/area.jl#L54-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.centroid-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T" href="#GeometryOps.centroid-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T"><code>GeometryOps.centroid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid(geom, [T=Float64])::Tuple{T, T}</code></pre><p>Returns the centroid of a given line segment, linear ring, polygon, or mutlipolygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/centroid.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.centroid_and_area-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T" href="#GeometryOps.centroid_and_area-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T"><code>GeometryOps.centroid_and_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_area(geom, [T=Float64])::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and area of a given geometry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/centroid.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.centroid_and_length-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T" href="#GeometryOps.centroid_and_length-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T"><code>GeometryOps.centroid_and_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">centroid_and_length(geom, [T=Float64])::(::Tuple{T, T}, ::Real)</code></pre><p>Returns the centroid and length of a given line/ring. Note this is only valid for line strings and linear rings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/centroid.jl#L67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.contains-Tuple{Any, Any}" href="#GeometryOps.contains-Tuple{Any, Any}"><code>GeometryOps.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contains(g1::AbstractGeometry, g2::AbstractGeometry)::Bool</code></pre><p>Return true if the second geometry is completely contained by the first geometry. The interiors of both geometries must intersect and the interior and boundary of the secondary (g2) must not intersect the exterior of the first (g1).</p><p><code>contains</code> returns the exact opposite result of <code>within</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
line = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
point = GI.Point((1, 2))

GO.contains(line, point)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/contains.jl#L43-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.coveredby-Tuple{Any, Any}" href="#GeometryOps.coveredby-Tuple{Any, Any}"><code>GeometryOps.coveredby</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coveredby(g1, g2)::Bool</code></pre><p>Return <code>true</code> if the first geometry is completely covered by the second geometry. The interior and boundary of the primary geometry (g1) must not intersect the exterior of the secondary geometry (g2).</p><p>Furthermore, <code>coveredby</code> returns the exact opposite result of <code>covers</code>. They are equivalent with the order of the arguments swapped.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
p1 = GI.Point(0.0, 0.0)
p2 = GI.Point(1.0, 1.0)
l1 = GI.Line([p1, p2])

GO.coveredby(p1, l1)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/coveredby.jl#L57-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.covers-Tuple{Any, Any}" href="#GeometryOps.covers-Tuple{Any, Any}"><code>GeometryOps.covers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">covers(g1::AbstractGeometry, g2::AbstractGeometry)::Bool</code></pre><p>Return true if the first geometry is completely covers the second geometry,  The exterior and boundary of the second geometry must not be outside of the interior and boundary of the first geometry. However, the interiors need not intersect.</p><p><code>covers</code> returns the exact opposite result of <code>coveredby</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
l1 = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
l2 = GI.LineString([(1, 1), (1, 2)])

GO.covers(l1, l2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/covers.jl#L42-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.crosses-Tuple{Any, Any}" href="#GeometryOps.crosses-Tuple{Any, Any}"><code>GeometryOps.crosses</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs"> crosses(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the intersection results in a geometry whose dimension is one less than the maximum dimension of the two source geometries and the intersection set is interior to both source geometries.</p><p>TODO: broken</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO
# TODO: Add working example</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/crosses.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.difference-Union{Tuple{Target}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where {T&lt;:AbstractFloat, Target&lt;:GeoInterface.AbstractTrait}" href="#GeometryOps.difference-Union{Tuple{Target}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where {T&lt;:AbstractFloat, Target&lt;:GeoInterface.AbstractTrait}"><code>GeometryOps.difference</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">difference(geom_a, geom_b, [T::Type]; target::Type)</code></pre><p>Return the difference between two geometries as a list of geometries. Return an empty list if none are found. The type of the list will be constrained as much as possible given the input geometries. Furthermore, the user can provide a <code>taget</code> type as a keyword argument and a list of target geometries found in the difference will be returned. The user can also provide a float type that they would like the points of returned geometries to be. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

poly1 = GI.Polygon([[[0.0, 0.0], [5.0, 5.0], [10.0, 0.0], [5.0, -5.0], [0.0, 0.0]]])
poly2 = GI.Polygon([[[3.0, 0.0], [8.0, 5.0], [13.0, 0.0], [8.0, -5.0], [3.0, 0.0]]])
diff_poly = GO.difference(poly1, poly2; target = GI.PolygonTrait)
GI.coordinates.(diff_poly)

# output
1-element Vector{Vector{Vector{Vector{Float64}}}}:
 [[[6.5, 3.5], [5.0, 5.0], [0.0, 0.0], [5.0, -5.0], [6.5, -3.5], [3.0, 0.0], [6.5, 3.5]]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/clipping/difference.jl#L5-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.disjoint-Tuple{Any, Any}" href="#GeometryOps.disjoint-Tuple{Any, Any}"><code>GeometryOps.disjoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">disjoint(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the first geometry is disjoint from the second geometry.</p><p>Return <code>true</code> if the first geometry is disjoint from the second geometry. The interiors and boundaries of both geometries must not intersect.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

line = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
point = (2, 2)
GO.disjoint(point, line)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/disjoint.jl#L54-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.distance-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T&lt;:AbstractFloat" href="#GeometryOps.distance-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T&lt;:AbstractFloat"><code>GeometryOps.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(point, geom, ::Type{T} = Float64)::T</code></pre><p>Calculates the  ditance from the geometry <code>g1</code> to the <code>point</code>. The distance will always be positive or zero.</p><p>The method will differ based on the type of the geometry provided:     - The distance from a point to a point is just the Euclidean distance     between the points.     - The distance from a point to a line is the minimum distance from the point     to the closest point on the given line.     - The distance from a point to a linestring is the minimum distance from the     point to the closest segment of the linestring.     - The distance from a point to a linear ring is the minimum distance from     the point to the closest segment of the linear ring.     - The distance from a point to a polygon is zero if the point is within the     polygon and otherwise is the minimum distance from the point to an edge of     the polygon. This includes edges created by holes.     - The distance from a point to a multigeometry or a geometry collection is     the minimum distance between the point and any of the sub-geometries.</p><p>Result will be of type T, where T is an optional argument with a default value of Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/distance.jl#L68-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.embed_extent-Tuple{Any}" href="#GeometryOps.embed_extent-Tuple{Any}"><code>GeometryOps.embed_extent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed_extent(obj)</code></pre><p>Recursively wrap the object with a GeoInterface.jl geometry, calculating and adding an <code>Extents.Extent</code> to all objects.</p><p>This can improve performance when extents need to be checked multiple times, such when needing to check if many points are in geometries, and using their extents as a quick filter for obviously exterior points.</p><p><strong>Keywords</strong></p><ul><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/extent.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-NTuple{4, Any}" href="#GeometryOps.equals-NTuple{4, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(trait_a, geom_a, trait_b, geom_b)</code></pre><p>Two geometries which are not of the same type cannot be equal so they always return false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{Any, Any}" href="#GeometryOps.equals-Tuple{Any, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(geom1, geom2)::Bool</code></pre><p>Compare two Geometries return true if they are the same geometry.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
poly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])
poly2 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])

GO.equals(poly1, poly2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L52-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, GeoInterface.LinearRingTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, GeoInterface.LinearRingTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(
    ::GI.LinearRingTrait, l1,
    ::GI.LinearRingTrait, l2,
)::Bool</code></pre><p>Two linear rings are equal if they share the same set of points going along the curve. Note that rings are closed by definition, so they can have, but don&#39;t need, a repeated last point to be equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L250-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.LinearRingTrait, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(
    ::GI.LinearRingTrait, l1,
    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,
)::Bool</code></pre><p>A linear ring and a line/linestring are equal if they share the same set of points going along the curve. Note that lines aren&#39;t closed by defintion, but rings are, so the line must have a repeated last point to be equal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L235-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.MultiPointTrait, mp1, ::GI.MultiPointTrait, mp2)::Bool</code></pre><p>Two multipoints are equal if they share the same set of points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.PointTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.PointTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.MultiPointTrait, mp1, ::GI.PointTrait, p2)::Bool</code></pre><p>A point and a multipoint are equal if the multipoint is composed of a single point that is equivalent to the given point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L115-L120">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool</code></pre><p>Two multipolygons are equal if they share the same set of polygons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L315-L319">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.MultiPolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool</code></pre><p>A polygon and a multipolygon are equal if the multipolygon is composed of a single polygon that is equivalent to the given polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L306-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.MultiPointTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PointTrait, p1, ::GI.MultiPointTrait, mp2)::Bool</code></pre><p>A point and a multipoint are equal if the multipoint is composed of a single point that is equivalent to the given point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.PointTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.PointTrait, Any, GeoInterface.PointTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PointTrait, p1, ::GI.PointTrait, p2)::Bool</code></pre><p>Two points are the same if they have the same x and y (and z if 3D) coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PolygonTrait, geom_a, ::GI.MultiPolygonTrait, geom_b)::Bool</code></pre><p>A polygon and a multipolygon are equal if the multipolygon is composed of a single polygon that is equivalent to the given polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L295-L300">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.equals-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::GI.PolygonTrait, geom_a, ::GI.PolygonTrait, geom_b)::Bool</code></pre><p>Two polygons are equal if they share the same exterior edge and holes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L265-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, GeoInterface.LinearRingTrait, Any}" href="#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, GeoInterface.LinearRingTrait, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(
    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,
    ::GI.LinearRingTrait, l2,
)::Bool</code></pre><p>A line/linestring and a linear ring are equal if they share the same set of points going along the curve. Note that lines aren&#39;t closed by defintion, but rings are, so the line must have a repeated last point to be equal</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L220-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}" href="#GeometryOps.equals-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.LineTrait}, Any}"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(
    ::Union{GI.LineTrait, GI.LineStringTrait}, l1,
    ::Union{GI.LineTrait, GI.LineStringTrait}, l2,
)::Bool</code></pre><p>Two lines/linestrings are equal if they share the same set of points going along the curve. Note that lines/linestrings aren&#39;t closed by defintion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L206-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.equals-Union{Tuple{T}, Tuple{T, Any, T, Any}} where T" href="#GeometryOps.equals-Union{Tuple{T}, Tuple{T, Any, T, Any}} where T"><code>GeometryOps.equals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equals(::T, geom_a, ::T, geom_b)::Bool</code></pre><p>Two geometries of the same type, which don&#39;t have a equals function to dispatch off of should throw an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/equals.jl#L73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target&lt;:GeoInterface.AbstractTrait" href="#GeometryOps.flatten-Union{Tuple{Target}, Tuple{Type{Target}, Any}} where Target&lt;:GeoInterface.AbstractTrait"><code>GeometryOps.flatten</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flatten(target::Type{&lt;:GI.AbstractTrait}, obj)
flatten(f, target::Type{&lt;:GI.AbstractTrait}, obj)</code></pre><p>Lazily flatten any <code>AbstractArray</code>, iterator, <code>FeatureCollectionTrait</code>, <code>FeatureTrait</code> or <code>AbstractGeometryTrait</code> object <code>obj</code>, so that objects with the <code>target</code> trait are returned by the iterator.</p><p>If <code>f</code> is passed in it will be applied to the target geometries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/primitives.jl#L300-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.flip-Tuple{Any}" href="#GeometryOps.flip-Tuple{Any}"><code>GeometryOps.flip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flip(obj)</code></pre><p>Swap all of the x and y coordinates in obj, otherwise keeping the original structure (but not necessarily the original type).</p><p><strong>Keywords</strong></p><ul><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li><li><code>calc_extent</code>: <code>true</code> or <code>false</code>. Whether to calculate the extent. Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/flip.jl#L6-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.get_contours-Tuple{AbstractMatrix}" href="#GeometryOps.get_contours-Tuple{AbstractMatrix}"><code>GeometryOps.get_contours</code></a> — <span class="docstring-category">Method</span></header><section><div><p>get_contours(A::AbstractMatrix)</p><p>Returns contours as vectors of <code>CartesianIndex</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/polygonize.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.intersection-Union{Tuple{Target}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where {T&lt;:AbstractFloat, Target&lt;:GeoInterface.AbstractTrait}" href="#GeometryOps.intersection-Union{Tuple{Target}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where {T&lt;:AbstractFloat, Target&lt;:GeoInterface.AbstractTrait}"><code>GeometryOps.intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection(geom_a, geom_b, [T::Type]; target::Type)</code></pre><p>Return the intersection between two geometries as a list of geometries. Return an empty list if none are found. The type of the list will be constrained as much as possible given the input geometries. Furthermore, the user can provide a <code>taget</code> type as a keyword argument and a list of target geometries found in the intersection will be returned. The user can also provide a float type that they would like the points of returned geometries to be. </p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

line1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])
line2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])
inter_points = GO.intersection(line1, line2; target = GI.PointTrait)
GI.coordinates.(inter_points)

# output
1-element Vector{Vector{Float64}}:
 [125.58375366067547, -14.83572303404496]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/clipping/intersection.jl#L5-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.intersection_points-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T&lt;:AbstractFloat" href="#GeometryOps.intersection_points-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T&lt;:AbstractFloat"><code>GeometryOps.intersection_points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersection_points(
    geom_a,
    geom_b,
)::Union{
    ::Vector{::Tuple{::Real, ::Real}},
    ::Nothing,
}</code></pre><p>Return a list of intersection points between two geometries of type GI.Point. If no intersection point was possible given geometry extents, returns an empty list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/clipping/intersection.jl#L87-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.intersects-Tuple{Any, Any}" href="#GeometryOps.intersects-Tuple{Any, Any}"><code>GeometryOps.intersects</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">intersects(geom1, geom2)::Bool</code></pre><p>Return true if the interiors or boundaries of the two geometries interact.</p><p><code>intersects</code> returns the exact opposite result of <code>disjoint</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

line1 = GI.Line([(124.584961,-12.768946), (126.738281,-17.224758)])
line2 = GI.Line([(123.354492,-15.961329), (127.22168,-14.008696)])
GO.intersects(line1, line2)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/intersects.jl#L38-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.isclockwise-Tuple{Any}" href="#GeometryOps.isclockwise-Tuple{Any}"><code>GeometryOps.isclockwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isclockwise(line::Union{LineString, Vector{Position}})::Bool</code></pre><p>Take a ring and return true or false whether or not the ring is clockwise or counter-clockwise.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

ring = GI.LinearRing([(0, 0), (1, 1), (1, 0), (0, 0)])
GO.isclockwise(ring)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/bools.jl#L9-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.isconcave-Tuple{Any}" href="#GeometryOps.isconcave-Tuple{Any}"><code>GeometryOps.isconcave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isconcave(poly::Polygon)::Bool</code></pre><p>Take a polygon and return true or false as to whether it is concave or not.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

poly = GI.Polygon([[(0, 0), (0, 1), (1, 1), (1, 0), (0, 0)]])
GO.isconcave(poly)

# output
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/bools.jl#L41-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{Any, Any}" href="#GeometryOps.overlaps-Tuple{Any, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(geom1, geom2)::Bool</code></pre><p>Compare two Geometries of the same dimension and return true if their intersection set results in a geometry different from both but of the same dimension. This means one geometry cannot be within or contain the other and they cannot be equal</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI
poly1 = GI.Polygon([[(0,0), (0,5), (5,5), (5,0), (0,0)]])
poly2 = GI.Polygon([[(1,1), (1,6), (6,6), (6,1), (1,1)]])

GO.overlaps(poly1, poly2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L53-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.AbstractTrait, Any, GeoInterface.AbstractTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(::GI.AbstractTrait, geom1, ::GI.AbstractTrait, geom2)::Bool</code></pre><p>For any non-specified pair, all have non-matching dimensions, return false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.LineTrait, Any, GeoInterface.LineTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(::GI.LineTrait, line1, ::GI.LineTrait, line)::Bool</code></pre><p>If the lines overlap, meaning that they are colinear but each have one endpoint outside of the other line, return true. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L116-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPointTrait, Any, GeoInterface.MultiPointTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.MultiPointTrait, points1,
    ::GI.MultiPointTrait, points2,
)::Bool</code></pre><p>If the multipoints overlap, meaning some, but not all, of the points within the multipoints are shared, return true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L86-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.MultiPolygonTrait, polys1,
    ::GI.MultiPolygonTrait, polys2,
)::Bool</code></pre><p>Return true if at least one pair of polygons from multipolygons overlap. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L196-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.MultiPolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.MultiPolygonTrait, polys1,
    ::GI.PolygonTrait, poly2,
)::Bool</code></pre><p>Return true if polygon overlaps with at least one of the polygons within the multipolygon. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L184-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.MultiPolygonTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::GI.PolygonTrait, poly1,
    ::GI.MultiPolygonTrait, polys2,
)::Bool</code></pre><p>Return true if polygon overlaps with at least one of the polygons within the multipolygon. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L165-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}" href="#GeometryOps.overlaps-Tuple{GeoInterface.PolygonTrait, Any, GeoInterface.PolygonTrait, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    trait_a::GI.PolygonTrait, poly_a,
    trait_b::GI.PolygonTrait, poly_b,
)::Bool</code></pre><p>If the two polygons intersect with one another, but are not equal, return true. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L147-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.overlaps-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any}" href="#GeometryOps.overlaps-Tuple{Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any, Union{GeoInterface.LineStringTrait, GeoInterface.Wrappers.LinearRing}, Any}"><code>GeometryOps.overlaps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">overlaps(
    ::Union{GI.LineStringTrait, GI.LinearRing}, line1,
    ::Union{GI.LineStringTrait, GI.LinearRing}, line2,
)::Bool</code></pre><p>If the curves overlap, meaning that at least one edge of each curve overlaps, return true. Else false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/overlaps.jl#L125-L133">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.polygon_to_line-Tuple{Any}" href="#GeometryOps.polygon_to_line-Tuple{Any}"><code>GeometryOps.polygon_to_line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polygon_to_line(poly::Polygon)</code></pre><p>Converts a Polygon to LineString or MultiLineString</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

poly = GI.Polygon([[(-2.275543, 53.464547), (-2.275543, 53.489271), (-2.215118, 53.489271), (-2.215118, 53.464547), (-2.275543, 53.464547)]])
GO.polygon_to_line(poly)
# output
GeoInterface.Wrappers.LineString{false, false, Vector{Tuple{Float64, Float64}}, Nothing, Nothing}([(-2.275543, 53.464547), (-2.275543, 53.489271), (-2.215118, 53.489271), (-2.215118, 53.464547), (-2.275543, 53.464547)], nothing, nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/utils.jl#L30-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.polygonize-Tuple{AbstractMatrix}" href="#GeometryOps.polygonize-Tuple{AbstractMatrix}"><code>GeometryOps.polygonize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">polygonize(A; minpoints=10)
polygonize(xs, ys, A; minpoints=10)</code></pre><p>Convert matrix <code>A</code> to polygons.</p><p>If <code>xs</code> and <code>ys</code> are passed in they are used as the pixel center points.</p><p><strong>Keywords</strong></p><ul><li><code>minpoints</code>: ignore polygons with less than <code>minpoints</code> points. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/polygonize.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.rebuild-Tuple{Any, Any}" href="#GeometryOps.rebuild-Tuple{Any, Any}"><code>GeometryOps.rebuild</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rebuild(geom, child_geoms)</code></pre><p>Rebuild a geometry from child geometries.</p><p>By default geometries will be rebuilt as a <code>GeoInterface.Wrappers</code> geometry, but <code>rebuild</code> can have methods added to it to dispatch on geometries from other packages and specify how to rebuild them.</p><p>(Maybe it should go into GeoInterface.jl)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/primitives.jl#L401-L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.reconstruct-Tuple{Any, Any}" href="#GeometryOps.reconstruct-Tuple{Any, Any}"><code>GeometryOps.reconstruct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reconstruct(geom, components)</code></pre><p>Reconstruct <code>geom</code> from an iterable of component objects that match its structure.</p><p>All objects in <code>components</code> must have the same <code>GeoInterface.trait</code>.</p><p>Ususally used in combination with <code>flatten</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/primitives.jl#L338-L346">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.reproject-Tuple{Any}" href="#GeometryOps.reproject-Tuple{Any}"><code>GeometryOps.reproject</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reproject(geometry; source_crs, target_crs, transform, always_xy, time)
reproject(geometry, source_crs, target_crs; always_xy, time)
reproject(geometry, transform; always_xy, time)</code></pre><p>Reproject any GeoInterface.jl compatible <code>geometry</code> from <code>source_crs</code> to <code>target_crs</code>.</p><p>The returned object will be constructed from <code>GeoInterface.WrapperGeometry</code> geometries, wrapping views of a <code>Vector{Proj.Point{D}}</code>, where <code>D</code> is the dimension.</p><p><strong>Arguments</strong></p><ul><li><code>geometry</code>: Any GeoInterface.jl compatible geometries.</li><li><code>source_crs</code>: the source coordinate referece system, as a GeoFormatTypes.jl object or a string.</li><li><code>target_crs</code>: the target coordinate referece system, as a GeoFormatTypes.jl object or a string.</li></ul><p>If these a passed as keywords, <code>transform</code> will take priority. Without it <code>target_crs</code> is always needed, and <code>source_crs</code> is needed if it is not retreivable from the geometry with <code>GeoInterface.crs(geometry)</code>.</p><p><strong>Keywords</strong></p><ul><li><code>always_xy</code>: force x, y coordinate order, <code>true</code> by default.   <code>false</code> will expect and return points in the crs coordinate order.</li><li><code>time</code>: the time for the coordinates. <code>Inf</code> by default.</li><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li><li><code>calc_extent</code>: <code>true</code> or <code>false</code>. Whether to calculate the extent. Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/reproject.jl#L11-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.signed_area-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat" href="#GeometryOps.signed_area-Union{Tuple{Any}, Tuple{T}, Tuple{Any, Type{T}}} where T&lt;:AbstractFloat"><code>GeometryOps.signed_area</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signed_area(geom, ::Type{T} = Float64)::T</code></pre><p>Returns the signed area of a single geometry, based on winding order.  This is computed slighly differently for different geometries:</p><pre><code class="nohighlight hljs">- The signed area of a point is always zero.
- The signed area of a curve is always zero.
- The signed area of a polygon is computed with the shoelace formula and is
positive if the polygon coordinates wind clockwise and negative if
counterclockwise.
- You cannot compute the signed area of a multipolygon as it doesn&#39;t have a
meaning as each sub-polygon could have a different winding order.</code></pre><p>Result will be of type T, where T is an optional argument with a default value of Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/area.jl#L77-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.signed_distance-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T&lt;:AbstractFloat" href="#GeometryOps.signed_distance-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where T&lt;:AbstractFloat"><code>GeometryOps.signed_distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">signed_distance(point, geom, ::Type{T} = Float64)::T</code></pre><p>Calculates the signed distance from the geometry <code>geom</code> to the given point. Points within <code>geom</code> have a negative signed distance, and points outside of <code>geom</code> have a positive signed distance.     - The signed distance from a point to a point, line, linestring, or linear     ring is equal to the distance between the two.     - The signed distance from a point to a polygon is negative if the point is     within the polygon and is positive otherwise. The value of the distance is     the minimum distance from the point to an edge of the polygon. This includes     edges created by holes.     - The signed distance from a point to a multigeometry or a geometry     collection is the minimum signed distance between the point and any of the     sub-geometries.</p><p>Result will be of type T, where T is an optional argument with a default value of Float64.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/distance.jl#L134-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.simplify-Tuple{GeometryOps.SimplifyAlg, Any}" href="#GeometryOps.simplify-Tuple{GeometryOps.SimplifyAlg, Any}"><code>GeometryOps.simplify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">simplify(obj; kw...)
simplify(::SimplifyAlg, obj; kw...)</code></pre><p>Simplify a geometry, feature, feature collection,  or nested vectors or a table of these.</p><p><a href="#GeometryOps.RadialDistance"><code>RadialDistance</code></a>, <a href="#GeometryOps.DouglasPeucker"><code>DouglasPeucker</code></a>, or  <a href="#GeometryOps.VisvalingamWhyatt"><code>VisvalingamWhyatt</code></a> algorithms are available,  listed in order of increasing quality but decreaseing performance.</p><p><code>PoinTrait</code> and <code>MultiPointTrait</code> are returned unchanged.</p><p>The default behaviour is <code>simplify(DouglasPeucker(; kw...), obj)</code>. Pass in other <a href="#GeometryOps.SimplifyAlg"><code>SimplifyAlg</code></a> to use other algorithms.</p><p><strong>Keywords</strong></p><ul><li><code>prefilter_alg</code>: <code>SimplifyAlg</code> algorithm used to pre-filter object before   using primary filtering algorithm.</li><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li><li><code>calc_extent</code>: <code>true</code> or <code>false</code>. Whether to calculate the extent. Defaults to <code>false</code>.</li></ul><p>Keywords for DouglasPeucker are allowed when no algorithm is specified:</p><p><strong>Keywords</strong></p><ul><li><p><code>ratio</code>: the fraction of points that should remain after <code>simplify</code>.    Useful as it will generalise for large collections of objects.</p></li><li><p><code>number</code>: the number of points that should remain after <code>simplify</code>.   Less useful for large collections of mixed size objects.</p></li><li><p><code>tol</code>: the minimum distance a point will be from the line   joining its neighboring points.</p></li></ul><p><strong>Example</strong></p><p>Simplify a polygon to have six points:</p><pre><code class="language-julia hljs">import GeoInterface as GI
import GeometryOps as GO

poly = GI.Polygon([[
    [-70.603637, -33.399918],
    [-70.614624, -33.395332],
    [-70.639343, -33.392466],
    [-70.659942, -33.394759],
    [-70.683975, -33.404504],
    [-70.697021, -33.419406],
    [-70.701141, -33.434306],
    [-70.700454, -33.446339],
    [-70.694274, -33.458369],
    [-70.682601, -33.465816],
    [-70.668869, -33.472117],
    [-70.646209, -33.473835],
    [-70.624923, -33.472117],
    [-70.609817, -33.468107],
    [-70.595397, -33.458369],
    [-70.587158, -33.442901],
    [-70.587158, -33.426283],
    [-70.590591, -33.414248],
    [-70.594711, -33.406224],
    [-70.603637, -33.399918]]])

simple = GO.simplify(poly; number=6)
GI.npoint(simple)

# output
6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/simplify.jl#L60-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1&lt;:Real, T2&lt;:Real}" href="#GeometryOps.t_value-Union{Tuple{T2}, Tuple{T1}, Tuple{N}, Tuple{Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, Union{Tuple{Vararg{T1, N}}, StaticArraysCore.StaticArray{Tuple{N}, T1, 1}}, T2, T2}} where {N, T1&lt;:Real, T2&lt;:Real}"><code>GeometryOps.t_value</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">t_value(sᵢ, sᵢ₊₁, rᵢ, rᵢ₊₁)</code></pre><p>Returns the &quot;T-value&quot; as described in Hormann&#39;s presentation <sup class="footnote-reference"><a id="citeref-HormannPresentation" href="#footnote-HormannPresentation">[HormannPresentation]</a></sup> on how to calculate the mean-value coordinate.  </p><p>Here, <code>sᵢ</code> is the vector from vertex <code>vᵢ</code> to the point, and <code>rᵢ</code> is the norm (length) of <code>sᵢ</code>. <code>s</code> must be <code>Point</code> and <code>r</code> must be real numbers.</p><p class="math-container">\[tᵢ = \frac{\mathrm{det}\left(sᵢ, sᵢ₊₁\right)}{rᵢ * rᵢ₊₁ + sᵢ ⋅ sᵢ₊₁}\]</p><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/barycentric.jl#L250-L266">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.to_edges-Tuple{Any}" href="#GeometryOps.to_edges-Tuple{Any}"><code>GeometryOps.to_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">to_edges()</code></pre><p>Convert any geometry or collection of geometries into a flat  vector of <code>Tuple{Tuple{Float64,Float64},Tuple{Float64,Float64}}</code> edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/utils.jl#L53-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.touches-Tuple{Any, Any}" href="#GeometryOps.touches-Tuple{Any, Any}"><code>GeometryOps.touches</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">touches(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the first geometry touches the second geometry. In other words, the two interiors cannot interact, but one of the geometries must have a boundary point that interacts with either the other geometies interior or boundary.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

l1 = GI.Line([(0.0, 0.0), (1.0, 0.0)])
l2 = GI.Line([(1.0, 1.0), (1.0, -1.0)])

GO.touches(l1, l2)
# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/touches.jl#L58-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.transform-Tuple{Any, Any}" href="#GeometryOps.transform-Tuple{Any, Any}"><code>GeometryOps.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform(f, obj)</code></pre><p>Apply a function <code>f</code> to all the points in <code>obj</code>.</p><p>Points will be passed to <code>f</code> as an <code>SVector</code> to allow using CoordinateTransformations.jl and Rotations.jl  without hassle.</p><p><code>SVector</code> is also a valid GeoInterface.jl point, so will work in all GeoInterface.jl methods.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; import GeoInterface as GI

julia&gt; import GeometryOps as GO

julia&gt; geom = GI.Polygon([GI.LinearRing([(1, 2), (3, 4), (5, 6), (1, 2)]), GI.LinearRing([(3, 4), (5, 6), (6, 7), (3, 4)])]);

julia&gt; f = CoordinateTransformations.Translation(3.5, 1.5)
Translation(3.5, 1.5)

julia&gt; GO.transform(f, geom)
GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}}, Nothing, Nothing}(GeoInterface.Wrappers.Linea
rRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}[GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}(StaticArraysCo
re.SVector{2, Float64}[[4.5, 3.5], [6.5, 5.5], [8.5, 7.5], [4.5, 3.5]], nothing, nothing), GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Float64}}, Nothing, Nothing}(StaticA
rraysCore.SVector{2, Float64}[[6.5, 5.5], [8.5, 7.5], [9.5, 8.5], [6.5, 5.5]], nothing, nothing)], nothing, nothing)</code></pre><p>With Rotations.jl you need to actuall multiply the Rotation by the <code>SVector</code> point, which is easy using an anonymous function.</p><pre><code class="language-julia hljs">julia&gt; using Rotations

julia&gt; GO.transform(p -&gt; one(RotMatrix{2}) * p, geom)
GeoInterface.Wrappers.Polygon{false, false, Vector{GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}}, Nothing, Nothing}(GeoInterface.Wrappers.LinearR
ing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}[GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}(StaticArraysCore.SVe
ctor{2, Int64}[[2, 1], [4, 3], [6, 5], [2, 1]], nothing, nothing), GeoInterface.Wrappers.LinearRing{false, false, Vector{StaticArraysCore.SVector{2, Int64}}, Nothing, Nothing}(StaticArraysCore.SVector{2, Int64
}[[4, 3], [6, 5], [7, 6], [4, 3]], nothing, nothing)], nothing, nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/transform.jl#L3-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.tuples-Tuple{Any}" href="#GeometryOps.tuples-Tuple{Any}"><code>GeometryOps.tuples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tuples(obj)</code></pre><p>Convert all points in <code>obj</code> to <code>Tuple</code>s, wherever the are nested.</p><p>Returns a similar object or collection of objects using GeoInterface.jl geometries wrapping <code>Tuple</code> points.</p><p><strong>Keywords</strong></p><ul><li><code>threaded</code>: <code>true</code> or <code>false</code>. Whether to use multithreading. Defaults to <code>false</code>.</li><li><code>crs</code>: The CRS to attach to geometries. Defaults to <code>nothing</code>.</li><li><code>calc_extent</code>: <code>true</code> or <code>false</code>. Whether to calculate the extent. Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/transformations/tuples.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.union-Union{Tuple{Target}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where {T&lt;:AbstractFloat, Target&lt;:GeoInterface.AbstractTrait}" href="#GeometryOps.union-Union{Tuple{Target}, Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, Type{T}}} where {T&lt;:AbstractFloat, Target&lt;:GeoInterface.AbstractTrait}"><code>GeometryOps.union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">union(geom_a, geom_b, [::Type{T}]; target::Type)</code></pre><p>Return the union between two geometries as a list of geometries. Return an empty list if none are found. The type of the list will be constrained as much as possible given the input geometries. Furthermore, the user can provide a <code>taget</code> type as a keyword argument and a list of target geometries found in the difference will be returned. The user can also provide a float type &#39;T&#39; that they would like the points of returned geometries to be. </p><p>Calculates the union between two polygons.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import GeoInterface as GI, GeometryOps as GO

p1 = GI.Polygon([[(0.0, 0.0), (5.0, 5.0), (10.0, 0.0), (5.0, -5.0), (0.0, 0.0)]])
p2 = GI.Polygon([[(3.0, 0.0), (8.0, 5.0), (13.0, 0.0), (8.0, -5.0), (3.0, 0.0)]])
union_poly = GO.union(p1, p2; target = GI.PolygonTrait)
GI.coordinates.(union_poly)

# output
1-element Vector{Vector{Vector{Vector{Float64}}}}:
 [[[6.5, 3.5], [5.0, 5.0], [0.0, 0.0], [5.0, -5.0], [6.5, -3.5], [8.0, -5.0], [13.0, 0.0], [8.0, 5.0], [6.5, 3.5]]]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/clipping/union.jl#L4-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.unwrap" href="#GeometryOps.unwrap"><code>GeometryOps.unwrap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unwrap(target::Type{&lt;:AbstractTrait}, obj)
unwrap(f, target::Type{&lt;:AbstractTrait}, obj)</code></pre><p>Unwrap the object to vectors, down to the target trait.</p><p>If <code>f</code> is passed in it will be applied to the target geometries as they are found.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/primitives.jl#L268-L276">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT&lt;:Real" href="#GeometryOps.weighted_mean-Union{Tuple{WT}, Tuple{WT, Any, Any}} where WT&lt;:Real"><code>GeometryOps.weighted_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">weighted_mean(weight::Real, x1, x2)</code></pre><p>Returns the weighted mean of <code>x1</code> and <code>x2</code>, where <code>weight</code> is the weight of <code>x1</code>.</p><p>Specifically, calculates <code>x1 * weight + x2 * (1 - weight)</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The idea for this method is that you can override this for custom types, like Color types, in extension modules.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/barycentric.jl#L207-L216">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="GeometryOps.within-Tuple{Any, Any}" href="#GeometryOps.within-Tuple{Any, Any}"><code>GeometryOps.within</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">within(geom1, geom2)::Bool</code></pre><p>Return <code>true</code> if the first geometry is completely within the second geometry. The interiors of both geometries must intersect and the interior and boundary of the primary geometry (geom1) must not intersect the exterior of the secondary geometry (geom2).</p><p>Furthermore, <code>within</code> returns the exact opposite result of <code>contains</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">import GeometryOps as GO, GeoInterface as GI

line = GI.LineString([(1, 1), (1, 2), (1, 3), (1, 4)])
point = (1, 2)
GO.within(point, line)

# output
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/asinghvi17/GeometryOps.jl/blob/0740ed9f13d7ca22d9f59effd25d323a6dd6d39b/src/methods/geom_relations/within.jl#L60-L81">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-HormannPresentation"><a class="tag is-link" href="#citeref-HormannPresentation">HormannPresentation</a>K. Hormann and N. Sukumar. Generalized Barycentric Coordinates in Computer Graphics and Computational Mechanics. Taylor &amp; Fancis, CRC Press, 2017.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../source/GeometryOps/">GeometryOps.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 5 February 2024 16:15">Monday 5 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
