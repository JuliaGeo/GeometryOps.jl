import{_ as t,c as o,o as a,az as r}from"./chunks/framework.CtMnb_9A.js";const u=JSON.parse('{"title":"Developer documentation","description":"","frontmatter":{},"headers":[],"relativePath":"explanations/devdocs.md","filePath":"explanations/devdocs.md","lastUpdated":null}'),n={name:"explanations/devdocs.md"};function i(s,e,d,l,p,c){return a(),o("div",null,[...e[0]||(e[0]=[r('<h1 id="Developer-documentation" tabindex="-1">Developer documentation <a class="header-anchor" href="#Developer-documentation" aria-label="Permalink to &quot;Developer documentation {#Developer-documentation}&quot;">​</a></h1><p>This is mostly some notes about how GeometryOps is structured, geared towards developers and folks interested in learning about the internals of GeometryOps.</p><h2 id="Coding-standards" tabindex="-1">Coding standards <a class="header-anchor" href="#Coding-standards" aria-label="Permalink to &quot;Coding standards {#Coding-standards}&quot;">​</a></h2><p>Every source file is also compiled into the documentation via Literate.jl, so it should have a Markdown section at the top that describes what that file does.</p><p>For most cases, each function has a single file, and so that file should:</p><ul><li><p>have a header which is the capitalized name of that function</p></li><li><p>have a docstring that is visible when you first load the page (collapsed or opened is up to you)</p></li><li><p>have some visual examples, rendered in the documentation, of what that function does! Since this is geometry, it&#39;s very easy to plot with e.g Makie.</p></li></ul><p>We also request that you define <a href="/GeometryOps.jl/previews/PR285/api#GeometryOpsCore.Algorithm"><code>Algorithm</code></a> types and use those to define the behaviour of your function. We don&#39;t have an operations interface yet (coming soon!) but that should be done as well!</p><h2 id="Geometry-representation" tabindex="-1">Geometry representation <a class="header-anchor" href="#Geometry-representation" aria-label="Permalink to &quot;Geometry representation {#Geometry-representation}&quot;">​</a></h2><p>In Julia there is no one fixed geometry representation; instead we can use any memory layout in a standardized way via <a href="https://github.com/JuliaGeo/GeoInterface.jl" target="_blank" rel="noreferrer">GeoInterface.jl</a>. This means iterating over <code>enumerate(GI.getpoint(geom))</code> rather than <code>1:length(geom)</code>, and similar.</p><p>However, sometimes you want a fast, in-Julia geometry with known layout. For example, <code>getpoint</code> on GEOS or GDAL geoms is quite slow because you have to make a <code>ccall</code> with a pointer. For cases like these you can simply use <code>GO.tuples</code> to convert geometries to <a href="https://juliageo.org/GeoInterface.jl/dev/guides/defaults/#Wrapper-types" target="_blank" rel="noreferrer">GeoInterface wrapper geometries</a> that wrap (usually) 2-tuple points in vectors.</p><p>When returning geometries you can generally return any GeoInterface geometry but should prefer such GeoInterface tuple geometries as mentioned above.</p>',11)])])}const m=t(n,[["render",i]]);export{u as __pageData,m as default};
